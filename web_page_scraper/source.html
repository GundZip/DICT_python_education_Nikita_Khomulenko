
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Документация Beautiful Soup &#8212; Beautiful Soup 4.9.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Beautiful Soup на русском языке" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Beautiful Soup на русском языке"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Beautiful Soup 4.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="beautiful-soup">
<h1>Документация Beautiful Soup<a class="headerlink" href="#beautiful-soup" title="Permalink to this headline">¶</a></h1>
<img alt="&quot;Лакей Карась начал с того, что вытащил из-под мышки огромный конверт (чуть ли не больше его самого).&quot;" class="align-right" src="_images/6.1.jpg" />
<p><a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> — это
библиотека Python для извлечения данных из файлов HTML и XML. Она работает
с вашим любимым парсером, чтобы дать вам естественные способы навигации,
поиска и изменения дерева разбора. Она обычно экономит программистам
часы и дни работы.</p>
<p>Эти инструкции иллюстрируют все основные функции Beautiful Soup 4
на примерах. Я покажу вам, для чего нужна библиотека, как она работает,
как ее использовать, как заставить ее делать то, что вы хотите, и что нужно делать, когда она
не оправдывает ваши ожидания.</p>
<p>Примеры в этой документации работают одинаково на Python 2.7
и Python 3.2.</p>
<p>Возможно, вы ищете документацию для <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup 3</a>.
Если это так, имейте в виду, что Beautiful Soup 3 больше не
развивается, и что поддержка этой версии будет прекращена
31 декабря 2020 года или немногим позже. Если вы хотите узнать о различиях между Beautiful Soup 3
и Beautiful Soup 4, читайте раздел <a class="reference internal" href="#bs4">Перенос кода на BS4</a>.</p>
<p>Эта документация переведена на другие языки
пользователями Beautiful Soup:</p>
<ul class="simple">
<li><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">这篇文档当然还有中文版.</a></li>
<li>このページは日本語で利用できます(<a class="reference external" href="http://kondou.com/BS4/">外部リンク</a>)</li>
<li><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/">이 문서는 한국어 번역도 가능합니다.</a></li>
<li><a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr/">Este documento também está disponível em Português do Brasil.</a></li>
</ul>
<div class="section" id="id5">
<h2>Техническая поддержка<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Если у вас есть вопросы о Beautiful Soup или возникли проблемы,
<a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">отправьте сообщение в дискуссионную группу</a>. Если
ваша проблема связана с разбором HTML-документа, не забудьте упомянуть,
<a class="reference internal" href="#diagnose"><span class="std std-ref">что говорит о нем функция diagnose()</span></a>.</p>
</div>
</div>
<div class="section" id="id7">
<h1>Быстрый старт<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h1>
<p>Вот HTML-документ, который я буду использовать в качестве примера в этой
документации. Это фрагмент из <cite>«Алисы в стране чудес»</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Прогон документа через Beautiful Soup дает нам
объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, который представляет документ в виде
вложенной структуры данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;title&gt;</span>
<span class="c1">#    The Dormouse&#39;s story</span>
<span class="c1">#   &lt;/title&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p class=&quot;title&quot;&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     The Dormouse&#39;s story</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#     Elsie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ,</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#     Lacie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    and</span>
<span class="c1">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span>
<span class="c1">#     Tillie</span>
<span class="c1">#    &lt;/a&gt;</span>
<span class="c1">#    ; and they lived at the bottom of a well.</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#   &lt;p class=&quot;story&quot;&gt;</span>
<span class="c1">#    ...</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Вот несколько простых способов навигации по этой структуре данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;head&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;title&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Одна из распространенных задач — извлечь все URL-адреса, найденные на странице в тегах &lt;a&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;href&#39;</span><span class="p">))</span>
<span class="c1"># http://example.com/elsie</span>
<span class="c1"># http://example.com/lacie</span>
<span class="c1"># http://example.com/tillie</span>
</pre></div>
</div>
<p>Другая распространенная задача — извлечь весь текст со страницы:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># The Dormouse&#39;s story</span>
<span class="c1">#</span>
<span class="c1"># Once upon a time there were three little sisters; and their names were</span>
<span class="c1"># Elsie,</span>
<span class="c1"># Lacie and</span>
<span class="c1"># Tillie;</span>
<span class="c1"># and they lived at the bottom of a well.</span>
<span class="c1">#</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>Это похоже на то, что вам нужно? Если да, продолжайте читать.</p>
</div>
<div class="section" id="id8">
<h1>Установка Beautiful Soup<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h1>
<p>Если вы используете последнюю версию Debian или Ubuntu Linux, вы можете
установить Beautiful Soup с помощью системы управления пакетами:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-bs4</kbd> (для Python 2)</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python3-bs4</kbd> (для Python 3)</p>
<p>Beautiful Soup 4 публикуется через PyPi, поэтому, если вы не можете установить библиотеку
с помощью системы управления пакетами, можно установить с помощью <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> или
<code class="docutils literal notranslate"><span class="pre">pip</span></code>. Пакет называется <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>. Один и тот же пакет
работает как на Python 2, так и на Python 3. Убедитесь, что вы используете версию
<code class="docutils literal notranslate"><span class="pre">pip</span></code> или <code class="docutils literal notranslate"><span class="pre">easy_install</span></code>, предназначенную для вашей версии Python (их можно назвать
<code class="docutils literal notranslate"><span class="pre">pip3</span></code> и <code class="docutils literal notranslate"><span class="pre">easy_install3</span></code> соответственно, если вы используете Python 3).</p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install beautifulsoup4</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install beautifulsoup4</kbd></p>
<p>(<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> — это, скорее всего, <cite>не тот</cite> пакет, который вам нужен. Это
предыдущий основной релиз, <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">Beautiful Soup 3</a>. Многие программы используют
BS3, так что он все еще доступен, но если вы пишете новый код,
нужно установить <code class="docutils literal notranslate"><span class="pre">beautifulsoup4</span></code>.)</p>
<p>Если у вас не установлены <code class="docutils literal notranslate"><span class="pre">easy_install</span></code> или <code class="docutils literal notranslate"><span class="pre">pip</span></code>, вы можете
<a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/download/4.x/">скачать архив с исходным кодом Beautiful Soup 4</a> и
установить его с помощью <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>.</p>
<p><kbd class="kbd docutils literal notranslate">$ python setup.py install</kbd></p>
<p>Если ничего не помогает, лицензия на Beautiful Soup позволяет
упаковать библиотеку целиком вместе с вашим приложением. Вы можете скачать
tar-архив, скопировать из него в кодовую базу вашего приложения каталог <code class="docutils literal notranslate"><span class="pre">bs4</span></code>
и использовать Beautiful Soup, не устанавливая его вообще.</p>
<p>Я использую Python 2.7 и Python 3.2 для разработки Beautiful Soup, но библиотека
должна работать и с более поздними версиями Python.</p>
<div class="section" id="id9">
<h2>Проблемы после установки<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup упакован как код Python 2. Когда вы устанавливаете его для
использования с Python 3, он автоматически конвертируется в код Python 3. Если
вы не устанавливаете библиотеку в виде пакета, код не будет сконвертирован. Были
также сообщения об установке неправильной версии на компьютерах с
Windows.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> “No module named HTMLParser”, ваша
проблема в том, что вы используете версию кода на Python 2, работая на
Python 3.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> “No module named html.parser”, ваша
проблема в том, что вы используете версию кода на Python 3, работая на
Python 2.</p>
<p>В обоих случаях лучше всего полностью удалить Beautiful
Soup  с вашей системы (включая любой каталог, созданный
при распаковке tar-архива) и запустить установку еще раз.</p>
<p>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> “Invalid syntax” в строке
<code class="docutils literal notranslate"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span> <span class="pre">u'[document]'</span></code>, вам нужно конвертировать код из Python 2
в Python 3. Вы можете установить пакет:</p>
<p><kbd class="kbd docutils literal notranslate">$ python3 setup.py install</kbd></p>
<p>или запустить вручную Python-скрипт <code class="docutils literal notranslate"><span class="pre">2to3</span></code>
в каталоге <code class="docutils literal notranslate"><span class="pre">bs4</span></code>:</p>
<p><kbd class="kbd docutils literal notranslate">$ 2to3-3.2 -w bs4</kbd></p>
</div>
<div class="section" id="parser-installation">
<span id="id10"></span><h2>Установка парсера<a class="headerlink" href="#parser-installation" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup поддерживает парсер HTML, включенный в стандартную библиотеку Python,
а также ряд сторонних парсеров на Python.
Одним из них является <a class="reference external" href="http://lxml.de/">парсер lxml</a>. В зависимости от ваших настроек,
вы можете установить lxml с помощью одной из следующих команд:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-lxml</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install lxml</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install lxml</kbd></p>
<p>Другая альтернатива — написанный исключительно на Python <a class="reference external" href="http://code.google.com/p/html5lib/">парсер html5lib</a>, который разбирает HTML таким же образом,
как это делает веб-браузер. В зависимости от ваших настроек, вы можете установить html5lib
с помощью одной из этих команд:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-html5lib</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install html5lib</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install html5lib</kbd></p>
<p>Эта таблица суммирует преимущества и недостатки каждого парсера:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="35%" />
<col width="26%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Парсер</td>
<td>Типичное использование</td>
<td>Преимущества</td>
<td>Недостатки</td>
</tr>
<tr class="row-even"><td>html.parser от Python</td>
<td><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html.parser&quot;)</span></code></td>
<td><ul class="first last simple">
<li>Входит в комплект</li>
<li>Приличная скорость</li>
<li>Нестрогий (по крайней мере,
в Python 2.7.3 и 3.2.)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Не такой быстрый, как
lxml, более строгий,
чем html5lib.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>HTML-парсер в lxml</td>
<td><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;lxml&quot;)</span></code></td>
<td><ul class="first last simple">
<li>Очень быстрый</li>
<li>Нестрогий</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Внешняя зависимость
от C</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>XML-парсер в lxml</td>
<td><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;lxml-xml&quot;)</span></code>
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;xml&quot;)</span></code></td>
<td><ul class="first last simple">
<li>Очень быстрый</li>
<li>Единственный XML-парсер,
который сейчас поддерживается</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Внешняя зависимость
от C</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>html5lib</td>
<td><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(markup,</span> <span class="pre">&quot;html5lib&quot;)</span></code></td>
<td><ul class="first last simple">
<li>Очень нестрогий</li>
<li>Разбирает страницы так же,
как это делает браузер</li>
<li>Создает валидный HTML5</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Очень медленный</li>
<li>Внешняя зависимость
от Python</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Я рекомендую по возможности установить и использовать lxml для быстродействия. Если вы
используете версию Python 2 более раннюю, чем 2.7.3, или версию Python 3
более раннюю, чем 3.2.2, <cite>необходимо</cite> установить lxml или
html5lib, потому что встроенный в Python парсер HTML просто недостаточно хорош в старых
версиях.</p>
<p>Обратите внимание, что если документ невалиден, различные парсеры будут генерировать
дерево Beautiful Soup для этого документа по-разному. Ищите подробности в разделе <a class="reference internal" href="#id51">Различия
между парсерами</a>.</p>
</div>
</div>
<div class="section" id="id11">
<h1>Приготовление супа<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h1>
<p>Чтобы разобрать документ, передайте его в
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Вы можете передать строку или открытый дескриптор файла:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;index.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;html&gt;data&lt;/html&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Первым делом документ конвертируется в Unicode, а HTML-мнемоники
конвертируются в символы Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre>BeautifulSoup(&quot;Sacr&amp;eacute; bleu!&quot;)
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;
</pre></div>
</div>
<p>Затем Beautiful Soup анализирует документ, используя лучший из доступных
парсеров. Библиотека будет использовать HTML-парсер, если вы явно не укажете,
что нужно использовать XML-парсер. (См. <a class="reference internal" href="#xml">Разбор XML</a>.)</p>
</div>
<div class="section" id="id12">
<h1>Виды объектов<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup превращает сложный HTML-документ в сложное дерево
объектов Python. Однако вам придется иметь дело только с четырьмя
<cite>видами</cite> объектов: <code class="docutils literal notranslate"><span class="pre">Tag</span></code>, <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
и <code class="docutils literal notranslate"><span class="pre">Comment</span></code>.</p>
<div class="section" id="tag">
<span id="id13"></span><h2><code class="docutils literal notranslate"><span class="pre">Tag</span></code><a class="headerlink" href="#tag" title="Permalink to this headline">¶</a></h2>
<p>Объект <code class="docutils literal notranslate"><span class="pre">Tag</span></code> соответствует тегу XML или HTML в исходном документе:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Tag&#39;&gt;</span>
</pre></div>
</div>
<p>У объекта Tag (далее «тег») много атрибутов и методов, и я расскажу о большинстве из них
в разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>. На данный момент наиболее
важными особенностями тега являются его имя и атрибуты.</p>
<div class="section" id="id14">
<h3>Имя<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>У каждого тега есть имя, доступное как <code class="docutils literal notranslate"><span class="pre">.name</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;b&#39;</span>
</pre></div>
</div>
<p>Если вы измените имя тега, это изменение будет отражено в любой HTML-
разметке, созданной Beautiful Soup:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>Атрибуты<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>У тега может быть любое количество атрибутов. Тег <code class="docutils literal notranslate"><span class="pre">&lt;b</span>
<span class="pre">id</span> <span class="pre">=</span> <span class="pre">&quot;boldest&quot;&gt;</span></code> имеет атрибут “id”, значение которого равно
“boldest”. Вы можете получить доступ к атрибутам тега, обращаясь с тегом как
со словарем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;boldest&#39;</span>
</pre></div>
</div>
<p>Вы можете получить доступ к этому словарю напрямую как к <code class="docutils literal notranslate"><span class="pre">.attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">attrs</span>
<span class="c1"># {u&#39;id&#39;: &#39;boldest&#39;}</span>
</pre></div>
</div>
<p>Вы можете добавлять, удалять и изменять атрибуты тега. Опять же, это
делается путем обращения с тегом как со словарем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;b another-attribute=&quot;1&quot; id=&quot;verybold&quot;&gt;&lt;/b&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;another-attribute&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;&lt;/b&gt;</span>

<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># KeyError: &#39;id&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">))</span>
<span class="c1"># None</span>
</pre></div>
</div>
<div class="section" id="multivalue">
<span id="id16"></span><h4>Многозначные атрибуты<a class="headerlink" href="#multivalue" title="Permalink to this headline">¶</a></h4>
<p>В HTML 4 определено несколько атрибутов, которые могут иметь множество значений. В HTML 5
пара таких атрибутов удалена, но определено еще несколько. Самый распространённый из
многозначных атрибутов — это <code class="docutils literal notranslate"><span class="pre">class</span></code> (т. е. тег может иметь более
одного класса CSS). Среди прочих <code class="docutils literal notranslate"><span class="pre">rel</span></code>, <code class="docutils literal notranslate"><span class="pre">rev</span></code>, <code class="docutils literal notranslate"><span class="pre">accept-charset</span></code>,
<code class="docutils literal notranslate"><span class="pre">headers</span></code> и <code class="docutils literal notranslate"><span class="pre">accesskey</span></code>. Beautiful Soup представляет значение(я)
многозначного атрибута в виде списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&quot;body&quot;]</span>

<span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [&quot;body&quot;, &quot;strikeout&quot;]</span>
</pre></div>
</div>
<p>Если атрибут <cite>выглядит</cite> так, будто он имеет более одного значения, но это не
многозначный атрибут, определенный какой-либо версией HTML-
стандарта, Beautiful Soup оставит атрибут как есть:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">id_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="c1"># &#39;my id&#39;</span>
</pre></div>
</div>
<p>Когда вы преобразовываете тег обратно в строку, несколько значений атрибута
объединяются:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">rel_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span>
<span class="c1"># [&#39;index&#39;]</span>
<span class="n">rel_soup</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;contents&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rel_soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Вы можете отключить объединение, передав <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span> <span class="pre">=</span> <span class="pre">None</span></code> в качестве
именованного аргумента в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">no_list_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;html&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">no_list_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">get_attribute_list</span></code>, того чтобы получить значение в виде списка,
независимо от того, является ли атрибут многозначным или нет:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">id_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get_attribute_list</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="c1"># [&quot;my id&quot;]</span>
</pre></div>
</div>
<p>Если вы разбираете документ как XML, многозначных атрибутов не будет:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># u&#39;body strikeout&#39;</span>
</pre></div>
</div>
<p>Опять же, вы можете поменять настройку, используя аргумент <code class="docutils literal notranslate"><span class="pre">multi_valued_attributes</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">class_is_multi</span><span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;*&#39;</span> <span class="p">:</span> <span class="s1">&#39;class&#39;</span><span class="p">}</span>
<span class="n">xml_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">multi_valued_attributes</span><span class="o">=</span><span class="n">class_is_multi</span><span class="p">)</span>
<span class="n">xml_soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="c1"># [u&#39;body&#39;, u&#39;strikeout&#39;]</span>
</pre></div>
</div>
<p>Вряд ли вам это пригодится, но если все-таки будет нужно, руководствуйтесь значениями
по умолчанию. Они реализуют правила, описанные в спецификации HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4.builder</span> <span class="k">import</span> <span class="n">builder_registry</span>
<span class="n">builder_registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">DEFAULT_CDATA_LIST_ATTRIBUTES</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="navigablestring">
<h2><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code><a class="headerlink" href="#navigablestring" title="Permalink to this headline">¶</a></h2>
<p>Строка соответствует фрагменту текста в теге. Beautiful Soup
использует класс <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> для хранения этих фрагментов текста:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> похожа на строку Unicode в Python, не считая того,
что она также поддерживает некоторые функции, описанные в
разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>. Вы можете конвертировать
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> в строку Unicode с помощью <code class="docutils literal notranslate"><span class="pre">unicode()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">unicode_string</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">unicode_string</span>
<span class="c1"># u&#39;Extremely bold&#39;</span>
<span class="nb">type</span><span class="p">(</span><span class="n">unicode_string</span><span class="p">)</span>
<span class="c1"># &lt;type &#39;unicode&#39;&gt;</span>
</pre></div>
</div>
<p>Вы не можете редактировать строку непосредственно, но вы можете заменить одну строку
другой, используя <a class="reference internal" href="#replace-with"><span class="std std-ref">replace_with()</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="s2">&quot;No longer bold&quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> поддерживает большинство функций, описанных в
разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>, но
не все. В частности, поскольку строка не может ничего содержать (в том смысле,
в котором тег может содержать строку или другой тег), строки не поддерживают
атрибуты <code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.string</span></code> или метод <code class="docutils literal notranslate"><span class="pre">find()</span></code>.</p>
<p>Если вы хотите использовать <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> вне Beautiful Soup,
вам нужно вызвать метод <code class="docutils literal notranslate"><span class="pre">unicode()</span></code>, чтобы превратить ее в обычную для Python
строку Unicode. Если вы этого не сделаете, ваша строка будет тащить за собой
ссылку на все дерево разбора Beautiful Soup, даже когда вы
закончите использовать Beautiful Soup. Это большой расход памяти.</p>
</div>
<div class="section" id="beautifulsoup">
<h2><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code><a class="headerlink" href="#beautifulsoup" title="Permalink to this headline">¶</a></h2>
<p>Объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> представляет разобранный документ как единое
целое. В большинстве случаев вы можете рассматривать его как объект
<a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>. Это означает, что он поддерживает большинство методов, описанных
в разделах <a class="reference internal" href="#id18">Навигация по дереву</a> и <a class="reference internal" href="#id27">Поиск по дереву</a>.</p>
<p>Вы также можете передать объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> в один из методов,
перечисленных в разделе <a class="reference internal" href="#id42">Изменение дерева</a>, по аналогии с передачей объекта <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>. Это
позволяет вам делать такие вещи, как объединение двух разобранных документов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;document&gt;&lt;content/&gt;INSERT FOOTER HERE&lt;/document&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="n">footer</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;footer&gt;Here&#39;s the footer&lt;/footer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;INSERT FOOTER HERE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">footer</span><span class="p">)</span>
<span class="c1"># u&#39;INSERT FOOTER HERE&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="c1"># &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="c1"># &lt;document&gt;&lt;content/&gt;&lt;footer&gt;Here&#39;s the footer&lt;/footer&gt;&lt;/document&gt;</span>
</pre></div>
</div>
<p>Поскольку объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> не соответствует действительному
HTML- или XML-тегу, у него нет имени и атрибутов. Однако иногда
бывает полезно взглянуть на <code class="docutils literal notranslate"><span class="pre">.name</span></code> объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, поэтому ему было присвоено специальное «имя»
<code class="docutils literal notranslate"><span class="pre">.name</span></code> “[document]”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;[document]&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>Комментарии и другие специфичные строки<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag</span></code>, <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> и <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> охватывают почти
все, с чем вы столкнётесь в файле HTML или XML, но осталось
ещё немного. Пожалуй, единственное, о чем стоит волноваться,
это комментарий:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="nb">type</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.element.Comment&#39;&gt;</span>
</pre></div>
</div>
<p>Объект <code class="docutils literal notranslate"><span class="pre">Comment</span></code> — это просто особый тип <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">comment</span>
<span class="c1"># u&#39;Hey, buddy. Want to buy a used parser&#39;</span>
</pre></div>
</div>
<p>Но когда он появляется как часть HTML-документа, <code class="docutils literal notranslate"><span class="pre">Comment</span></code>
отображается со специальным форматированием:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;b&gt;</span>
<span class="c1">#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;</span>
<span class="c1"># &lt;/b&gt;</span>
</pre></div>
</div>
<p>Beautiful Soup определяет классы для всего, что может появиться в
XML-документе: <code class="docutils literal notranslate"><span class="pre">CData</span></code>, <code class="docutils literal notranslate"><span class="pre">ProcessingInstruction</span></code>,
<code class="docutils literal notranslate"><span class="pre">Declaration</span></code> и <code class="docutils literal notranslate"><span class="pre">Doctype</span></code>. Как и <code class="docutils literal notranslate"><span class="pre">Comment</span></code>, эти классы
являются подклассами <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, которые добавляют что-то еще к
строке. Вот пример, который заменяет комментарий блоком
CDATA:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">CData</span>
<span class="n">cdata</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">&quot;A CDATA block&quot;</span><span class="p">)</span>
<span class="n">comment</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">cdata</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;b&gt;</span>
<span class="c1">#  &lt;![CDATA[A CDATA block]]&gt;</span>
<span class="c1"># &lt;/b&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id18">
<h1>Навигация по дереву<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h1>
<p>Вернемся к HTML-документу с фрагментом из «Алисы в стране чудес»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Я буду использовать его в качестве примера, чтобы показать, как перейти от одной части
документа к другой.</p>
<div class="section" id="id19">
<h2>Проход сверху вниз<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>Теги могут содержать строки и другие теги. Эти элементы являются
дочерними (<cite>children</cite>) для тега. Beautiful Soup предоставляет множество различных атрибутов для
навигации и перебора дочерних элементов.</p>
<p>Обратите внимание, что строки Beautiful Soup не поддерживают ни один из этих
атрибутов, потому что строка не может иметь дочерних элементов.</p>
<div class="section" id="id20">
<h3>Навигация с использованием имен тегов<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>Самый простой способ навигации по дереву разбора — это указать имя
тега, который вам нужен. Если вы хотите получить тег &lt;head&gt;, просто напишите <code class="docutils literal notranslate"><span class="pre">soup.head</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Вы можете повторять этот трюк многократно, чтобы подробнее рассмотреть определенную часть
дерева разбора. Следующий код извлекает первый тег &lt;b&gt; внутри тега &lt;body&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;</span>
</pre></div>
</div>
<p>Использование имени тега в качестве атрибута даст вам только <cite>первый</cite> тег с таким
именем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вам нужно получить <cite>все</cite> теги &lt;a&gt; или что-нибудь более сложное,
чем первый тег с определенным именем, вам нужно использовать один из
методов, описанных в разделе <a class="reference internal" href="#id27">Поиск по дереву</a>, такой как <cite>find_all()</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="contents-children">
<h3><code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.children</span></code><a class="headerlink" href="#contents-children" title="Permalink to this headline">¶</a></h3>
<p>Дочерние элементы доступны в списке под названием <code class="docutils literal notranslate"><span class="pre">.contents</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">head_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">head</span>
<span class="n">head_tag</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;]</span>

<span class="n">title_tag</span> <span class="o">=</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;The Dormouse&#39;s story&#39;]</span>
</pre></div>
</div>
<p>Сам объект <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> имеет дочерние элементы. В этом случае
тег &lt;html&gt; является дочерним для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">len</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
<span class="c1"># 1</span>
<span class="n">soup</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># u&#39;html&#39;</span>
</pre></div>
</div>
<p>У строки нет <code class="docutils literal notranslate"><span class="pre">.contents</span></code>, потому что она не может содержать
ничего:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">text</span> <span class="o">=</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">text</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># AttributeError: У объекта &#39;NavigableString&#39; нет атрибута &#39;contents&#39;</span>
</pre></div>
</div>
<p>Вместо того, чтобы получать дочерние элементы в виде списка, вы можете перебирать их
с помощью генератора <code class="docutils literal notranslate"><span class="pre">.children</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">title_tag</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
</div>
<div class="section" id="descendants">
<h3><code class="docutils literal notranslate"><span class="pre">.descendants</span></code><a class="headerlink" href="#descendants" title="Permalink to this headline">¶</a></h3>
<p>Атрибуты <code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.children</span></code> применяются только в отношении
<cite>непосредственных</cite> дочерних элементов тега. Например, тег &lt;head&gt; имеет только один непосредственный
дочерний тег &lt;title&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>Но у самого тега &lt;title&gt; есть дочерний элемент: строка “The Dormouse’s
story”. В некотором смысле эта строка также является дочерним элементом
тега &lt;head&gt;. Атрибут <code class="docutils literal notranslate"><span class="pre">.descendants</span></code> позволяет перебирать <cite>все</cite>
дочерние элементы тега рекурсивно: его непосредственные дочерние элементы, дочерние элементы
дочерних элементов и так далее:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">head_tag</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="c1"># The Dormouse&#39;s story</span>
</pre></div>
</div>
<p>У тега &lt;head&gt; есть только один дочерний элемент, но при этом у него два потомка:
тег &lt;title&gt; и его дочерний элемент. У объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
только один прямой дочерний элемент (тег &lt;html&gt;), зато множество
потомков:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
<span class="c1"># 1</span>
<span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">))</span>
<span class="c1"># 25</span>
</pre></div>
</div>
</div>
<div class="section" id="string">
<span id="id21"></span><h3><code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h3>
<p>Если у тега есть только один дочерний элемент, и это <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>,
его можно получить через <code class="docutils literal notranslate"><span class="pre">.string</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>Если единственным дочерним элементом тега является другой тег, и у этого <cite>другого</cite> тега есть строка
<code class="docutils literal notranslate"><span class="pre">.string</span></code>, то считается, что родительский тег содержит ту же строку
<code class="docutils literal notranslate"><span class="pre">.string</span></code>, что и дочерний тег:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">head_tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">head_tag</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;The Dormouse&#39;s story&#39;</span>
</pre></div>
</div>
<p>Если тег содержит больше чем один элемент, то становится неясным, какая из строк
<code class="docutils literal notranslate"><span class="pre">.string</span></code> относится и к родительскому тегу, поэтому <code class="docutils literal notranslate"><span class="pre">.string</span></code> родительского тега имеет значение
<code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="strings-stripped-strings">
<span id="string-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.strings</span></code> и <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code><a class="headerlink" href="#strings-stripped-strings" title="Permalink to this headline">¶</a></h3>
<p>Если внутри тега есть более одного элемента, вы все равно можете посмотреть только на
строки. Используйте генератор <code class="docutils literal notranslate"><span class="pre">.strings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
<span class="c1"># u&#39;Elsie&#39;</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># u&#39;Lacie&#39;</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
</pre></div>
</div>
<p>В этих строках много лишних пробелов, которые вы можете
удалить, используя генератор <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&quot;The Dormouse&#39;s story&quot;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were&#39;</span>
<span class="c1"># u&#39;Elsie&#39;</span>
<span class="c1"># u&#39;,&#39;</span>
<span class="c1"># u&#39;Lacie&#39;</span>
<span class="c1"># u&#39;and&#39;</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;...&#39;</span>
</pre></div>
</div>
<p>Здесь строки, состоящие исключительно из пробелов, игнорируются, а
пробелы в начале и конце строк удаляются.</p>
</div>
</div>
<div class="section" id="id22">
<h2>Проход снизу вверх<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>В продолжение аналогии с «семейным деревом», каждый тег и каждая строка имеет
родителя (<cite>parent</cite>): тег, который его содержит.</p>
<div class="section" id="parent">
<span id="id23"></span><h3><code class="docutils literal notranslate"><span class="pre">.parent</span></code><a class="headerlink" href="#parent" title="Permalink to this headline">¶</a></h3>
<p>Вы можете получить доступ к родительскому элементу с помощью атрибута <code class="docutils literal notranslate"><span class="pre">.parent</span></code>. В
примере документа с фрагментом из «Алисы в стране чудес» тег &lt;head&gt; является родительским
для тега &lt;title&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">title_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">title</span>
<span class="n">title_tag</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
<span class="n">title_tag</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
</pre></div>
</div>
<p>Строка заголовка сама имеет родителя: тег &lt;title&gt;, содержащий
ее:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">title_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Родительским элементом тега верхнего уровня, такого как &lt;html&gt;, является сам объект
<code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">html_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">html</span>
<span class="nb">type</span><span class="p">(</span><span class="n">html_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># &lt;class &#39;bs4.BeautifulSoup&#39;&gt;</span>
</pre></div>
</div>
<p>И <code class="docutils literal notranslate"><span class="pre">.parent</span></code> объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> определяется как None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
<div class="section" id="parents">
<span id="id24"></span><h3><code class="docutils literal notranslate"><span class="pre">.parents</span></code><a class="headerlink" href="#parents" title="Permalink to this headline">¶</a></h3>
<p>Вы можете перебрать всех родителей элемента с помощью
<code class="docutils literal notranslate"><span class="pre">.parents</span></code>. В следующем примере <code class="docutils literal notranslate"><span class="pre">.parents</span></code> используется для перемещения от тега &lt;a&gt;,
закопанного глубоко внутри документа, до самого верха документа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">link</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># p</span>
<span class="c1"># body</span>
<span class="c1"># html</span>
<span class="c1"># [document]</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>Перемещение вбок<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<p>Рассмотрим простой документ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">sibling_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;a&gt;</span>
<span class="c1">#    &lt;b&gt;</span>
<span class="c1">#     text1</span>
<span class="c1">#    &lt;/b&gt;</span>
<span class="c1">#    &lt;c&gt;</span>
<span class="c1">#     text2</span>
<span class="c1">#    &lt;/c&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Тег &lt;b&gt; и тег &lt;c&gt; находятся на одном уровне: они оба непосредственные
дочерние элементы одного и того же тега. Мы называем их <cite>одноуровневые</cite>. Когда документ
красиво отформатирован, одноуровневые элементы выводятся с одинаковым  отступом. Вы
также можете использовать это отношение в написанном вами коде.</p>
<div class="section" id="next-sibling-previous-sibling">
<h3><code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code><a class="headerlink" href="#next-sibling-previous-sibling" title="Permalink to this headline">¶</a></h3>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code> для навигации
между элементами страницы, которые находятся на одном уровне дерева разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;c&gt;text2&lt;/c&gt;</span>

<span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">previous_sibling</span>
<span class="c1"># &lt;b&gt;text1&lt;/b&gt;</span>
</pre></div>
</div>
<p>У тега &lt;b&gt; есть <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>, но нет <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>,
потому что нет ничего до тега &lt;b&gt; <cite>на том же уровне
дерева</cite>. По той же причине у тега &lt;c&gt; есть <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>,
но нет <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">previous_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Строки “text1” и “text2” <cite>не являются</cite> одноуровневыми, потому что они не
имеют общего родителя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;text1&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sibling_soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>В реальных документах <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> или <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code>
тега обычно будет строкой, содержащей пробелы. Возвращаясь к
фрагменту из «Алисы в стране чудес»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/elsie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link1&quot;</span><span class="o">&gt;</span><span class="n">Elsie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/lacie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="o">&gt;</span><span class="n">Lacie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/tillie&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="o">&gt;</span><span class="n">Tillie</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Вы можете подумать, что <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> первого тега &lt;a&gt;
должен быть второй тег &lt;a&gt;. Но на самом деле это строка: запятая и
перевод строки, отделяющий первый тег &lt;a&gt; от второго:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># u&#39;,\n&#39;</span>
</pre></div>
</div>
<p>Второй тег &lt;a&gt; на самом деле является <code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> запятой</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">link</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-siblings-previous-siblings">
<span id="sibling-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code><a class="headerlink" href="#next-siblings-previous-siblings" title="Permalink to this headline">¶</a></h3>
<p>Вы можете перебрать одноуровневые элементы данного тега с помощью <code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> или
<code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
<span class="c1"># u&#39;; and they lived at the bottom of a well.&#39;</span>
<span class="c1"># None</span>

<span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">previous_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
<span class="c1"># &#39; and\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span>
<span class="c1"># u&#39;,\n&#39;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>Проход вперед и назад<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<p>Взгляните на начало фрагмента из «Алисы в стране чудес»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;&lt;</span><span class="n">head</span><span class="o">&gt;&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="o">&lt;</span><span class="n">p</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>HTML-парсер берет эту строку символов и превращает ее в
серию событий: “открыть тег &lt;html&gt;”, “открыть тег &lt;head&gt;”, “открыть
тег &lt;html&gt;”, “добавить строку”, “закрыть тег &lt;title&gt;”, “открыть
тег &lt;p&gt;” и так далее. Beautiful Soup предлагает инструменты для реконструирование
первоначального разбора документа.</p>
<div class="section" id="next-element-previous-element">
<span id="element-generators"></span><h3><code class="docutils literal notranslate"><span class="pre">.next_element</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_element</span></code><a class="headerlink" href="#next-element-previous-element" title="Permalink to this headline">¶</a></h3>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> строки или тега указывает на то,
что было разобрано непосредственно после него. Это могло бы быть тем же, что и
<code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code>, но обычно результат резко отличается.</p>
<p>Возьмем последний тег &lt;a&gt; в фрагменте из «Алисы в стране чудес». Его
<code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> является строкой: конец предложения, которое было
прервано началом тега &lt;a&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">last_a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_a_tag</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_sibling</span>
<span class="c1"># &#39;; and they lived at the bottom of a well.&#39;</span>
</pre></div>
</div>
<p>Но <code class="docutils literal notranslate"><span class="pre">.next_element</span></code> этого тега &lt;a&gt; — это то, что было разобрано
сразу после тега &lt;a&gt;, <cite>не</cite> остальная часть этого предложения:
это слово “Tillie”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># u&#39;Tillie&#39;</span>
</pre></div>
</div>
<p>Это потому, что в оригинальной разметке слово «Tillie» появилось
перед точкой с запятой. Парсер обнаружил тег &lt;a&gt;, затем
слово «Tillie», затем закрывающий тег &lt;/a&gt;, затем точку с запятой и оставшуюся
часть предложения. Точка с запятой находится на том же уровне, что и тег &lt;a&gt;, но
слово «Tillie» встретилось первым.</p>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">.previous_element</span></code> является полной противоположностью
<code class="docutils literal notranslate"><span class="pre">.next_element</span></code>. Он указывает на элемент, который был встречен при разборе
непосредственно перед текущим:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c1"># u&#39; and\n&#39;</span>
<span class="n">last_a_tag</span><span class="o">.</span><span class="n">previous_element</span><span class="o">.</span><span class="n">next_element</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="next-elements-previous-elements">
<h3><code class="docutils literal notranslate"><span class="pre">.next_elements</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_elements</span></code><a class="headerlink" href="#next-elements-previous-elements" title="Permalink to this headline">¶</a></h3>
<p>Вы уже должны были уловить идею. Вы можете использовать их для перемещения
вперед или назад по документу, в том порядке, в каком он был разобран парсером:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
<span class="c1"># None</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id27">
<h1>Поиск по дереву<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup определяет множество методов поиска по дереву разбора,
но они все очень похожи. Я буду долго объяснять, как работают
два самых популярных метода: <code class="docutils literal notranslate"><span class="pre">find()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>. Прочие
методы принимают практически те же самые аргументы, поэтому я расскажу
о них вкратце.</p>
<p>И опять, я буду использовать фрагмент из «Алисы в стране чудес» в качестве примера:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span> <span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Передав фильтр в аргумент типа <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, вы можете
углубиться в интересующие вас части документа.</p>
<div class="section" id="id28">
<h2>Виды фильтров<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h2>
<p>Прежде чем подробно рассказывать о <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и подобных методах, я
хочу показать примеры различных фильтров, которые вы можете передать в эти
методы. Эти фильтры появляются снова и снова в
поисковом API. Вы можете использовать их для фильтрации по имени тега,
по его атрибутам, по тексту строки или по некоторой их
комбинации.</p>
<div class="section" id="a-string">
<span id="id29"></span><h3>Строка<a class="headerlink" href="#a-string" title="Permalink to this headline">¶</a></h3>
<p>Самый простой фильтр — это строка. Передайте строку в метод поиска, и
Beautiful Soup выполнит поиск соответствия этой строке. Следующий
код находит все теги &lt;b&gt; в документе:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</span>
</pre></div>
</div>
<p>Если вы передадите байтовую строку, Beautiful Soup будет считать, что строка
кодируется в UTF-8. Вы можете избежать этого, передав вместо нее строку Unicode.</p>
</div>
<div class="section" id="a-regular-expression">
<span id="id30"></span><h3>Регулярное выражение<a class="headerlink" href="#a-regular-expression" title="Permalink to this headline">¶</a></h3>
<p>Если вы передадите объект с регулярным выражением, Beautiful Soup отфильтрует результаты
в соответствии с этим регулярным выражением, используя его метод <code class="docutils literal notranslate"><span class="pre">search()</span></code>. Следующий код
находит все теги, имена которых начинаются с буквы “b”; в нашем
случае это теги &lt;body&gt; и &lt;b&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^b&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># body</span>
<span class="c1"># b</span>
</pre></div>
</div>
<p>Этот код находит все теги, имена которых содержат букву “t”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># title</span>
</pre></div>
</div>
</div>
<div class="section" id="a-list">
<span id="id31"></span><h3>Список<a class="headerlink" href="#a-list" title="Permalink to this headline">¶</a></h3>
<p>Если вы передадите список, Beautiful Soup разрешит совпадение строк
с <cite>любым</cite> элементом из этого списка. Следующий код находит все теги &lt;a&gt;
<cite>и</cite> все теги &lt;b&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>
<span class="c1"># [&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="true">
<span id="the-value-true"></span><h3><code class="docutils literal notranslate"><span class="pre">True</span></code><a class="headerlink" href="#true" title="Permalink to this headline">¶</a></h3>
<p>Значение <code class="docutils literal notranslate"><span class="pre">True</span></code> подходит везде, где возможно.. Следующий код находит <cite>все</cite>
теги в документе, но не текстовые строки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># html</span>
<span class="c1"># head</span>
<span class="c1"># title</span>
<span class="c1"># body</span>
<span class="c1"># p</span>
<span class="c1"># b</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3>Функция<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>Если ничто из перечисленного вам не подходит, определите функцию, которая
принимает элемент в качестве единственного аргумента. Функция должна вернуть
<code class="docutils literal notranslate"><span class="pre">True</span></code>, если аргумент подходит, и <code class="docutils literal notranslate"><span class="pre">False</span></code>, если нет.</p>
<p>Вот функция, которая возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, если в теге определен атрибут “class”,
но не определен атрибут “id”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Передайте эту функцию в <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, и вы получите все
теги &lt;p&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Эта функция выбирает только теги &lt;p&gt;. Она не выбирает теги &lt;a&gt;,
поскольку в них определены и атрибут “class” , и атрибут “id”. Она не выбирает
теги вроде &lt;html&gt; и &lt;title&gt;, потому что в них не определен атрибут
“class”.</p>
<p>Если вы передаете функцию для фильтрации по определенному атрибуту, такому как
<code class="docutils literal notranslate"><span class="pre">href</span></code>, аргументом, переданным в функцию, будет
значение атрибута, а не весь тег. Вот функция, которая находит все теги <code class="docutils literal notranslate"><span class="pre">a</span></code>,
у которых атрибут <code class="docutils literal notranslate"><span class="pre">href</span></code> <em>не</em> соответствует регулярному выражению:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">def</span> <span class="nf">not_lacie</span><span class="p">(</span><span class="n">href</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">href</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;lacie&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">href</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">not_lacie</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Функция может быть настолько сложной, насколько вам нужно. Вот
функция, которая возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, если тег окружен строковыми
объектами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">NavigableString</span>
<span class="k">def</span> <span class="nf">surrounded_by_strings</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">next_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">previous_element</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">))</span>

<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">surrounded_by_strings</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">tag</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># p</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># a</span>
<span class="c1"># p</span>
</pre></div>
</div>
<p>Теперь мы готовы подробно рассмотреть методы поиска.</p>
</div>
</div>
<div class="section" id="find-all">
<h2><code class="docutils literal notranslate"><span class="pre">find_all()</span></code><a class="headerlink" href="#find-all" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_all(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#recursive"><span class="std std-ref">recursive</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> просматривает потомков тега и
извлекает <cite>всех</cite> потомков, которые соответствую вашим фильтрам. Я привел несколько
примеров в разделе <a class="reference internal" href="#id28">Виды фильтров</a>, а вот еще несколько:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;sisters&quot;</span><span class="p">))</span>
<span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
</pre></div>
</div>
<p>Кое-что из этого нам уже знакомо, но есть и новое. Что означает
передача значения для <code class="docutils literal notranslate"><span class="pre">string</span></code> или <code class="docutils literal notranslate"><span class="pre">id</span></code>? Почему
<code class="docutils literal notranslate"><span class="pre">find_all</span> <span class="pre">(&quot;p&quot;,</span> <span class="pre">&quot;title&quot;)</span></code> находит тег &lt;p&gt; с CSS-классом “title”?
Давайте посмотрим на аргументы <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>.</p>
<div class="section" id="name">
<span id="id33"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">name</span></code><a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h3>
<p>Передайте значение для аргумента <code class="docutils literal notranslate"><span class="pre">name</span></code>, и вы скажете Beautiful Soup
рассматривать только теги с определенными именами. Текстовые строки будут игнорироваться, так же как и
теги, имена которых не соответствуют заданным.</p>
<p>Вот простейший пример использования:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>В разделе  <a class="reference internal" href="#id28">Виды фильтров</a> говорилось, что значением <code class="docutils literal notranslate"><span class="pre">name</span></code> может быть
<a class="reference internal" href="#id29">строка</a>, <a class="reference internal" href="#id30">регулярное выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или
<a class="reference internal" href="#true">True</a>.</p>
</div>
<div class="section" id="kwargs">
<span id="id34"></span><h3>Именованные аргументы<a class="headerlink" href="#kwargs" title="Permalink to this headline">¶</a></h3>
<p>Любой нераспознанный аргумент будет превращен в фильтр
по атрибуту тега. Если вы передаете значение для аргумента с именем <code class="docutils literal notranslate"><span class="pre">id</span></code>,
Beautiful Soup будет фильтровать по атрибуту “id” каждого тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link2&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Если вы передадите значение для <code class="docutils literal notranslate"><span class="pre">href</span></code>, Beautiful Soup отфильтрует
по атрибуту “href” каждого тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Для фильтрации по атрибуту может использоваться <a class="reference internal" href="#id29">строка</a>, <a class="reference internal" href="#id30">регулярное
выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или значение <a class="reference internal" href="#true">True</a>.</p>
<p>Следующий код находит все теги, атрибут <code class="docutils literal notranslate"><span class="pre">id</span></code> которых имеет значение,
независимо от того, что это за значение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Вы можете отфильтровать несколько атрибутов одновременно, передав более одного
именованного аргумента:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;elsie&quot;</span><span class="p">),</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link1&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Некоторые атрибуты, такие как атрибуты data-* в HTML 5, имеют имена, которые
нельзя использовать в качестве имен именованных аргументов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">data_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#39;</span><span class="p">)</span>
<span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="c1"># SyntaxError: keyword can&#39;t be an expression</span>
</pre></div>
</div>
<p>Вы можете использовать эти атрибуты в поиске, поместив их в
словарь и передав словарь в <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> как
аргумент <code class="docutils literal notranslate"><span class="pre">attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data-foo&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span>
</pre></div>
</div>
<p>Нельзя использовать именованный аргумент для поиска в HTML по элементу “name”,
потому что Beautiful Soup использует аргумент <code class="docutils literal notranslate"><span class="pre">name</span></code> для имени
самого тега. Вместо этого вы можете передать элемент “name” вместе с его значением в
составе аргумента <code class="docutils literal notranslate"><span class="pre">attrs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">name_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;input name=&quot;email&quot;/&gt;&#39;</span><span class="p">)</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;email&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
<span class="n">name_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;email&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;input name=&quot;email&quot;/&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="css">
<span id="attrs"></span><h3>Поиск по классу CSS<a class="headerlink" href="#css" title="Permalink to this headline">¶</a></h3>
<p>Очень удобно искать тег с определенным классом CSS, но
имя атрибута CSS, “class”, является зарезервированным словом в
Python. Использование <code class="docutils literal notranslate"><span class="pre">class</span></code> в качестве именованного аргумента приведет к синтаксической
ошибке. Начиная с Beautiful Soup 4.1.2, вы можете выполнять поиск по классу CSS, используя
именованный аргумент <code class="docutils literal notranslate"><span class="pre">class_</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Как и с любым именованным аргументом, вы можете передать в качестве значения <code class="docutils literal notranslate"><span class="pre">class_</span></code> строку, регулярное
выражение, функцию или <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;itl&quot;</span><span class="p">))</span>
<span class="c1"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="k">def</span> <span class="nf">has_six_characters</span><span class="p">(</span><span class="n">css_class</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">css_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">css_class</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="n">has_six_characters</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Помните, что один тег может иметь <a class="reference internal" href="#multivalue"><span class="std std-ref">несколько значений</span></a>
для атрибута “class”. Когда вы ищете тег, который
соответствует определенному классу CSS, вы ищете соответствие <cite>любому</cite> из его
классов CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">css_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>

<span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Можно искать точное строковое значение атрибута <code class="docutils literal notranslate"><span class="pre">class</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;body strikeout&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Но поиск вариантов строкового значения не сработает:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">css_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;strikeout body&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Если вы хотите искать теги, которые соответствуют двум или более классам CSS,
следует использовать селектор CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">css_soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p.strikeout.body&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;]</span>
</pre></div>
</div>
<p>В старых версиях Beautiful Soup, в которых нет ярлыка <code class="docutils literal notranslate"><span class="pre">class_</span></code>
можно использовать трюк  с аргументом <code class="docutils literal notranslate"><span class="pre">attrs</span></code>, упомянутый выше. Создайте
словарь, значение которого для “class” является строкой (или регулярным
выражением, или чем угодно еще), которую вы хотите найти:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="s2">&quot;sister&quot;</span><span class="p">})</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id35">
<span id="id36"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">string</span></code><a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>С помощью <code class="docutils literal notranslate"><span class="pre">string</span></code> вы можете искать строки вместо тегов. Как и в случае с
<code class="docutils literal notranslate"><span class="pre">name</span></code> и именованными аргументами, передаваться может <a class="reference internal" href="#id29">строка</a>,
<a class="reference internal" href="#id30">регулярное выражение</a>, <a class="reference internal" href="#id31">список</a>, <a class="reference internal" href="#id32">функция</a> или значения <a class="reference internal" href="#true">True</a>.
Вот несколько примеров:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Tillie&quot;</span><span class="p">,</span> <span class="s2">&quot;Elsie&quot;</span><span class="p">,</span> <span class="s2">&quot;Lacie&quot;</span><span class="p">])</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;Dormouse&quot;</span><span class="p">))</span>
<span class="p">[</span><span class="s2">u&quot;The Dormouse&#39;s story&quot;</span><span class="p">,</span> <span class="s2">u&quot;The Dormouse&#39;s story&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">is_the_only_string_within_a_tag</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if this string is the only child of its parent tag.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_the_only_string_within_a_tag</span><span class="p">)</span>
<span class="c1"># [u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;, u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;, u&#39;...&#39;]</span>
</pre></div>
</div>
<p>Хотя значение типа <code class="docutils literal notranslate"><span class="pre">string</span></code> предназначено для поиска строк, вы можете комбинировать его с
аргументами, которые находят теги: Beautiful Soup найдет все теги, в которых
<code class="docutils literal notranslate"><span class="pre">.string</span></code> соответствует вашему значению для <code class="docutils literal notranslate"><span class="pre">string</span></code>. Следующий код находит все теги &lt;a&gt;,
у которых <code class="docutils literal notranslate"><span class="pre">.string</span></code> равно “Elsie”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">string</span></code> — это новое в Beautiful Soup 4.4.0. В ранних
версиях он назывался <code class="docutils literal notranslate"><span class="pre">text</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Elsie&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="limit">
<span id="id37"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">limit</span></code><a class="headerlink" href="#limit" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает все теги и строки, которые соответствуют вашим
фильтрам. Это может занять некоторое время, если документ большой. Если вам не
нужны <cite>все</cite> результаты, вы можете указать их предельное число — <code class="docutils literal notranslate"><span class="pre">limit</span></code>. Это
работает так же, как ключевое слово LIMIT в SQL. Оно говорит Beautiful Soup
прекратить собирать результаты после того, как их найдено определенное количество.</p>
<p>В фрагменте из «Алисы в стране чудес» есть три ссылки, но следующий код
находит только первые две:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="recursive">
<span id="id38"></span><h3>Аргумент <code class="docutils literal notranslate"><span class="pre">recursive</span></code><a class="headerlink" href="#recursive" title="Permalink to this headline">¶</a></h3>
<p>Если вы вызовете <code class="docutils literal notranslate"><span class="pre">mytag.find_all()</span></code>, Beautiful Soup проверит всех
потомков <code class="docutils literal notranslate"><span class="pre">mytag</span></code>: его дочерние элементы, дочерние элементы дочерних элементов, и
так далее. Если вы хотите, чтобы Beautiful Soup рассматривал только непосредственных потомков (дочерние элементы),
вы можете передать <code class="docutils literal notranslate"><span class="pre">recursive</span> <span class="pre">=</span> <span class="pre">False</span></code>. Оцените разницу:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Вот эта часть документа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span>
   <span class="n">The</span> <span class="n">Dormouse</span><span class="s1">&#39;s story</span>
  <span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Тег &lt;title&gt; находится под тегом &lt;html&gt;, но не <cite>непосредственно</cite>
под тегом &lt;html&gt;: на пути встречается тег &lt;head&gt;. Beautiful Soup
находит тег &lt;title&gt;, когда разрешено просматривать всех потомков
тега &lt;html&gt;, но когда <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code> ограничивает поиск
только непосредстввенно дочерними элементами,  Beautiful Soup ничего не находит.</p>
<p>Beautiful Soup предлагает множество методов поиска по дереву (они рассмотрены ниже),
и они в основном принимают те же аргументы, что и <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>: <code class="docutils literal notranslate"><span class="pre">name</span></code>,
<code class="docutils literal notranslate"><span class="pre">attrs</span></code>, <code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">limit</span></code> и именованные аргументы. Но
с аргументом <code class="docutils literal notranslate"><span class="pre">recursive</span></code> все иначе:  <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и <code class="docutils literal notranslate"><span class="pre">find()</span></code> —
это единственные методы, которые его поддерживают. От передачи <code class="docutils literal notranslate"><span class="pre">recursive=False</span></code> в
метод типа <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> не очень много пользы.</p>
</div>
</div>
<div class="section" id="id39">
<h2>Вызов тега похож на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code><a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h2>
<p>Поскольку <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> является самым популярным методом в Beautiful
Soup API, вы можете использовать сокращенную запись. Если относиться к
объекту  <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или объекту <code class="docutils literal notranslate"><span class="pre">Tag</span></code> так, будто это
функция, то это похоже на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>
﻿с этим объектом. Эти две строки кода эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Эти две строки также эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="find">
<h2><code class="docutils literal notranslate"><span class="pre">find()</span></code><a class="headerlink" href="#find" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#recursive"><span class="std std-ref">recursive</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> сканирует весь документ в поиске
всех результатов, но иногда вам нужен только один. Если вы знаете,
что в документе есть только один тег &lt;body&gt;, нет смысла сканировать
весь документ в поиске остальных. Вместо того, чтобы передавать <code class="docutils literal notranslate"><span class="pre">limit=1</span></code>
каждый раз, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, используйте
метод <code class="docutils literal notranslate"><span class="pre">find()</span></code>. Эти две строки кода эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Разница лишь в том, что <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает список, содержащий
единственный результат, а <code class="docutils literal notranslate"><span class="pre">find()</span></code> возвращает только сам результат.</p>
<p>Если <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> не может ничего найти, он возвращает пустой список. Если
<code class="docutils literal notranslate"><span class="pre">find()</span></code> не может ничего найти, он возвращает <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;nosuchtag&quot;</span><span class="p">))</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Помните трюк с <code class="docutils literal notranslate"><span class="pre">soup.head.title</span></code> из раздела
<a class="reference internal" href="#id20">Навигация с использованием имен тегов</a>? Этот трюк работает на основе неоднократного вызова <code class="docutils literal notranslate"><span class="pre">find()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;head&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-parents-find-parent">
<h2><code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code><a class="headerlink" href="#find-parents-find-parent" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_parents(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_parent(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Я долго объяснял, как работают <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и
<code class="docutils literal notranslate"><span class="pre">find()</span></code>. Beautiful Soup API определяет десяток других методов для
поиска по дереву, но пусть вас это не пугает. Пять из этих методов
в целом похожи на <code class="docutils literal notranslate"><span class="pre">find_all()</span></code>, а другие пять в целом
похожи на <code class="docutils literal notranslate"><span class="pre">find()</span></code>. Единственное различие в том, по каким частям
дерева они ищут.</p>
<p>Сначала давайте рассмотрим <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и
<code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>. Помните, что <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> и <code class="docutils literal notranslate"><span class="pre">find()</span></code> прорабатывают
дерево сверху вниз, просматривая теги и их потомков. <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>
делают наоборот: они идут <cite>снизу вверх</cite>, рассматривая
родительские элементы тега или строки. Давайте испытаем их, начав со строки,
закопанной глубоко в фрагменте из «Алисы в стране чудес»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">a_string</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Lacie&quot;</span><span class="p">)</span>
<span class="n">a_string</span>
<span class="c1"># u&#39;Lacie&#39;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="c1">#  and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="n">a_string</span><span class="o">.</span><span class="n">find_parents</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Один из трех тегов &lt;a&gt; является прямым родителем искомой строки,
так что наш поиск находит его. Один из трех тегов &lt;p&gt; является
непрямым родителем строки, и наш поиск тоже его
находит. Где-то в документе есть тег &lt;p&gt; с классом CSS “title”,
но он не является родительским для строки, так что мы не можем найти
его с помощью <code class="docutils literal notranslate"><span class="pre">find_parents()</span></code>.</p>
<p>Вы могли заметить связь между <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code>,
<code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и атрибутами <a class="reference internal" href="#parent">.parent</a> и <a class="reference internal" href="#parents">.parents</a>,
упомянутыми ранее. Связь очень сильная. Эти методы поиска
на самом деле используют <code class="docutils literal notranslate"><span class="pre">.parents</span></code>, чтобы перебрать все родительские элементы и проверить
каждый из них на соответствие заданному фильтру.</p>
</div>
<div class="section" id="find-next-siblings-find-next-sibling">
<h2><code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code><a class="headerlink" href="#find-next-siblings-find-next-sibling" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_next_siblings(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_next_sibling(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#sibling-generators"><span class="std std-ref">.next_siblings</span></a> для
перебора одноуровневых элементов для данного элемента в дереве. Метод
<code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> возвращает все  подходящие одноуровневые элементы,
а <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code> возвращает только первый из них:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_next_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-previous-siblings-find-previous-sibling">
<h2><code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous_sibling()</span></code><a class="headerlink" href="#find-previous-siblings-find-previous-sibling" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_previous_siblings(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_previous_sibling(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#sibling-generators"><span class="std std-ref">.previous_siblings</span></a> для перебора тех одноуровневых элементов,
которые предшествуют данному элементу в дереве разбора. Метод <code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code>
возвращает все подходящие одноуровневые элементы,, а
а <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code> только первый из них:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">last_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link3&quot;</span><span class="p">)</span>
<span class="n">last_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span>

<span class="n">last_link</span><span class="o">.</span><span class="n">find_previous_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">first_story_paragraph</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;story&quot;</span><span class="p">)</span>
<span class="n">first_story_paragraph</span><span class="o">.</span><span class="n">find_previous_sibling</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="find-all-next-find-next">
<h2><code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next()</span></code><a class="headerlink" href="#find-all-next-find-next" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_all_next(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_next(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#element-generators"><span class="std std-ref">.next_elements</span></a> для
перебора любых тегов и строк, которые встречаются в документе после
элемента. Метод <code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> возвращает все совпадения, а
<code class="docutils literal notranslate"><span class="pre">find_next()</span></code> только первое:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_next</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c1">#  u&#39;;\nand they lived at the bottom of a well.&#39;, u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_next</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
</pre></div>
</div>
<p>В первом примере нашлась строка “Elsie”, хотя она
содержится в теге &lt;a&gt;, с которого мы начали. Во втором примере
нашелся последний тег &lt;p&gt;, хотя он находится
в другой части дерева, чем тег &lt;a&gt;, с которого мы начали. Для этих
методов имеет значение только то, что элемент соответствует фильтру и
появляется в документе позже, чем тот элемент, с которого начали поиск.</p>
</div>
<div class="section" id="find-all-previous-find-previous">
<h2><code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous()</span></code><a class="headerlink" href="#find-all-previous-find-previous" title="Permalink to this headline">¶</a></h2>
<p>Сигнатура: find_all_previous(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#limit"><span class="std std-ref">limit</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Сигнатура: find_previous(<a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>, <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>)</p>
<p>Эти методы используют <a class="reference internal" href="#element-generators"><span class="std std-ref">.previous_elements</span></a> для
перебора любых тегов и строк, которые встречаются в документе до
элемента. Метод <code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> возвращает все совпадения, а
<code class="docutils literal notranslate"><span class="pre">find_previous()</span></code> только первое:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">first_link</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">first_link</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_all_previous</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;]</span>

<span class="n">first_link</span><span class="o">.</span><span class="n">find_previous</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</span>
</pre></div>
</div>
<p>Вызов <code class="docutils literal notranslate"><span class="pre">find_all_previous</span> <span class="pre">(&quot;p&quot;)</span></code> нашел первый абзац в
документе (тот, который с <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">=</span> <span class="pre">&quot;title&quot;</span></code>), но он также находит
второй абзац, а именно тег &lt;p&gt;, содержащий тег &lt;a&gt;, с которого мы
начали. Это не так уж удивительно: мы смотрим на все теги,
которые появляются в документе раньше, чем тот, с которого мы начали. Тег
&lt;p&gt;, содержащий тег &lt;a&gt;, должен был появиться до тега &lt;a&gt;, который
в нем содержится.</p>
</div>
<div class="section" id="id40">
<h2>Селекторы CSS<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
<p>Начиная с версии 4.7.0, Beautiful Soup поддерживает большинство селекторов CSS4 благодаря
проекту <a class="reference external" href="https://facelessuser.github.io/soupsieve/">SoupSieve</a>. Если вы установили Beautiful Soup через <code class="docutils literal notranslate"><span class="pre">pip</span></code>, одновременно должен был установиться SoupSieve,
так что вам больше ничего не нужно делать.</p>
<p>В <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> есть метод <code class="docutils literal notranslate"><span class="pre">.select()</span></code>, который использует SoupSieve, чтобы
запустить селектор CSS и вернуть все
подходящие элементы. <code class="docutils literal notranslate"><span class="pre">Tag</span></code> имеет похожий метод, который запускает селектор CSS
в отношении содержимого одного тега.</p>
<p>(В более ранних версиях Beautiful Soup тоже есть метод <code class="docutils literal notranslate"><span class="pre">.select()</span></code>,
но поддерживаются только наиболее часто используемые селекторы CSS.)</p>
<p>В <a class="reference external" href="https://facelessuser.github.io/soupsieve/">документации SoupSieve</a> перечислены все
селекторы CSS, которые поддерживаются на данный момент, но вот некоторые из основных:</p>
<p>Вы можете найти теги:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p:nth-of-type(3)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span>
</pre></div>
</div>
<p>Найти теги под другими тегами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;html head title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</pre></div>
</div>
<p>Найти теги <cite>непосредственно</cite> под другими тегами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;head &gt; title&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; a:nth-of-type(2)&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;p &gt; #link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;body &gt; a&quot;</span><span class="p">)</span>
<span class="c1"># []</span>
</pre></div>
</div>
<p>Найти одноуровневые элементы тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 ~ .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot;  id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1 + .sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по классу CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;[class~=sister]&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по ID:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;a#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги, которые соответствуют любому селектору из списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;#link1,#link2&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Проверка на наличие атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Найти теги по значению атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href=&quot;http://example.com/elsie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href^=&quot;http://example.com/&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href$=&quot;tillie&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href*=&quot;.com/el&quot;]&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span>
</pre></div>
</div>
<p>Есть также метод <code class="docutils literal notranslate"><span class="pre">select_one()</span></code>, который находит только
первый тег, соответствующий селектору:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">select_one</span><span class="p">(</span><span class="s2">&quot;.sister&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вы разобрали XML, в котором определены пространства имен, вы можете использовать их в
селекторах CSS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
<span class="n">xml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;tag xmlns:ns1=&quot;http://namespace1/&quot; xmlns:ns2=&quot;http://namespace2/&quot;&gt;</span>
<span class="s2"> &lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;</span>
<span class="s2"> &lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;</span>
<span class="s2">&lt;/tag&gt; &quot;&quot;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;, &lt;ns2:child&gt;I&#39;m in namespace 2&lt;/ns2:child&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;ns1|child&quot;</span><span class="p">,</span> <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 1&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
<p>При обработке селектора CSS, который использует пространства имен, Beautiful Soup
использует сокращения пространства имен, найденные при разборе
документа. Вы можете заменить сокращения своими собственными, передав словарь
сокращений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">namespaces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="s2">&quot;http://namespace1/&quot;</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s2">&quot;http://namespace2/&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;second|child&quot;</span><span class="p">,</span> <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">)</span>
<span class="c1"># [&lt;ns1:child&gt;I&#39;m in namespace 2&lt;/ns1:child&gt;]</span>
</pre></div>
</div>
<p>Все эти селекторы CSS удобны для тех, кто уже
знаком с синтаксисом селекторов CSS. Вы можете сделать все это с помощью
Beautiful Soup API. И если CSS селекторы — это все, что вам нужно, вам следует
использовать парсер lxml: так будет намного быстрее. Но вы можете
<cite>комбинировать</cite> селекторы CSS с Beautiful Soup API.</p>
</div>
</div>
<div class="section" id="id42">
<h1>Изменение дерева<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h1>
<p>Основная сила Beautiful Soup в поиске по дереву разбора, но вы
также можете изменить дерево и записать свои изменения в виде нового HTML или
XML-документа.</p>
<div class="section" id="id43">
<h2>Изменение имен тегов и атрибутов<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h2>
<p>Я говорил об этом раньше, в разделе <a class="reference internal" href="#id15">Атрибуты</a>, но это стоит повторить. Вы
можете переименовать тег, изменить значения его атрибутов, добавить новые
атрибуты и удалить атрибуты:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">tag</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blockquote&quot;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;verybold&#39;</span>
<span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;</span>

<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">tag</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
<span class="n">tag</span>
<span class="c1"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>Изменение <code class="docutils literal notranslate"><span class="pre">.string</span></code><a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<p>Если вы замените значение атрибута <code class="docutils literal notranslate"><span class="pre">.string</span></code> новой строкой, содержимое тега будет
заменено на эту строку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>

<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;New link text.&quot;</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;New link text.&lt;/a&gt;</span>
</pre></div>
</div>
<p>Будьте осторожны: если тег содержит другие теги, они и все их
содержимое будет уничтожено.</p>
</div>
<div class="section" id="append">
<h2><code class="docutils literal notranslate"><span class="pre">append()</span></code><a class="headerlink" href="#append" title="Permalink to this headline">¶</a></h2>
<p>Вы можете добавить содержимое тега с помощью <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code>. Это работает
точно так же, как <code class="docutils literal notranslate"><span class="pre">.append()</span></code> для списка в Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Foo&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>

<span class="n">soup</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Foo&#39;, u&#39;Bar&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="extend">
<h2><code class="docutils literal notranslate"><span class="pre">extend()</span></code><a class="headerlink" href="#extend" title="Permalink to this headline">¶</a></h2>
<p>Начиная с версии Beautiful Soup 4.7.0, <code class="docutils literal notranslate"><span class="pre">Tag</span></code> также поддерживает метод
<code class="docutils literal notranslate"><span class="pre">.extend()</span></code>, который работает так же, как вызов <code class="docutils literal notranslate"><span class="pre">.extend()</span></code> для
списка в Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;Soup&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;&#39;s&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;on&quot;</span><span class="p">])</span>

<span class="n">soup</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;Soup&#39;s on&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Soup&#39;, u&#39;&#39;s&#39;, u&#39; &#39;, u&#39;on&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="navigablestring-new-tag">
<h2><code class="docutils literal notranslate"><span class="pre">NavigableString()</span></code> и <code class="docutils literal notranslate"><span class="pre">.new_tag()</span></code><a class="headerlink" href="#navigablestring-new-tag" title="Permalink to this headline">¶</a></h2>
<p>Если вам нужно добавить строку в документ, нет проблем — вы можете передать
строку Python в <code class="docutils literal notranslate"><span class="pre">append()</span></code> или вызвать
конструктор <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="n">new_string</span> <span class="o">=</span> <span class="n">NavigableString</span><span class="p">(</span><span class="s2">&quot; there&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_string</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there.&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Hello&#39;, u&#39; there&#39;]</span>
</pre></div>
</div>
<p>Если вы хотите создать комментарий или другой подкласс
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>, просто вызовите конструктор:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">Comment</span>
<span class="n">new_comment</span> <span class="o">=</span> <span class="n">Comment</span><span class="p">(</span><span class="s2">&quot;Nice to see you.&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comment</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;Hello&#39;, u&#39; there&#39;, u&#39;Nice to see you.&#39;]</span>
</pre></div>
</div>
<p>(Это новая функция в Beautiful Soup 4.4.0.)</p>
<p>Что делать, если вам нужно создать совершенно новый тег?  Наилучшим решением будет
вызвать фабричный метод <code class="docutils literal notranslate"><span class="pre">BeautifulSoup.new_tag()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">original_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">b</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://www.example.com&quot;</span><span class="p">)</span>
<span class="n">original_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;&lt;/a&gt;&lt;/b&gt;</span>

<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Link text.&quot;</span>
<span class="n">original_tag</span>
<span class="c1"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span>
</pre></div>
</div>
<p>Нужен только первый аргумент, имя тега.</p>
</div>
<div class="section" id="insert">
<h2><code class="docutils literal notranslate"><span class="pre">insert()</span></code><a class="headerlink" href="#insert" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.insert()</span></code> похож на <code class="docutils literal notranslate"><span class="pre">Tag.append()</span></code>, за исключением того, что новый элемент
не обязательно добавляется в конец родительского
<code class="docutils literal notranslate"><span class="pre">.contents</span></code>. Он добавится в любое место, номер которого
вы укажете. Это работает в точности как <code class="docutils literal notranslate"><span class="pre">.insert()</span></code> в списке Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;but did not endorse &quot;</span><span class="p">)</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span>
<span class="n">tag</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;I linked to &#39;, u&#39;but did not endorse&#39;, &lt;i&gt;example.com&lt;/i&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="insert-before-insert-after">
<h2><code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> и <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code><a class="headerlink" href="#insert-before-insert-after" title="Permalink to this headline">¶</a></h2>
<p>Метод <code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> вставляет теги или строки непосредственно
перед чем-то в дереве разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;stop&lt;/b&gt;&quot;</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
<span class="n">tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Don&#39;t&quot;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">insert_before</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt;stop&lt;/b&gt;</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code> вставляет теги или строки непосредственно
после чего-то в дереве разбора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">div</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
<span class="n">div</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;ever&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">insert_after</span><span class="p">(</span><span class="s2">&quot; you &quot;</span><span class="p">,</span> <span class="n">div</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span>
<span class="c1"># &lt;b&gt;&lt;i&gt;Don&#39;t&lt;/i&gt; you &lt;div&gt;ever&lt;/div&gt; stop&lt;/b&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [&lt;i&gt;Don&#39;t&lt;/i&gt;, u&#39; you&#39;, &lt;div&gt;ever&lt;/div&gt;, u&#39;stop&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="clear">
<h2><code class="docutils literal notranslate"><span class="pre">clear()</span></code><a class="headerlink" href="#clear" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.clear()</span></code> удаляет содержимое тега:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">tag</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="n">tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="extract">
<h2><code class="docutils literal notranslate"><span class="pre">extract()</span></code><a class="headerlink" href="#extract" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.extract()</span></code> удаляет тег или строку из дерева. Он
возвращает тег или строку, которая была извлечена:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">i_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>

<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;example.com&lt;/i&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">i_tag</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="kc">None</span>
</pre></div>
</div>
<p>К этому моменту у вас фактически есть два дерева разбора: одно в
объекте <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, который вы использовали, чтобы разобрать документ, другое в
теге, который был извлечен. Вы можете далее вызывать <code class="docutils literal notranslate"><span class="pre">extract</span></code> в отношении
дочернего элемента того тега, который был извлечен:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">my_string</span> <span class="o">=</span> <span class="n">i_tag</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
<span class="n">my_string</span>
<span class="c1"># u&#39;example.com&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">my_string</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># None</span>
<span class="n">i_tag</span>
<span class="c1"># &lt;i&gt;&lt;/i&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="decompose">
<h2><code class="docutils literal notranslate"><span class="pre">decompose()</span></code><a class="headerlink" href="#decompose" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.decompose()</span></code> удаляет тег из дерева, а затем <cite>полностью
уничтожает его вместе с его содержимым</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="replace-with">
<span id="id45"></span><h2><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code><a class="headerlink" href="#replace-with" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.extract()</span></code> удаляет тег или строку из дерева
и заменяет его тегом или строкой по вашему выбору:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">new_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">new_tag</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;example.net&quot;</span>
<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>

<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code> возвращает тег или строку, которые были заменены, так что
вы можете изучить его или добавить его обратно в другую часть дерева.</p>
</div>
<div class="section" id="wrap">
<h2><code class="docutils literal notranslate"><span class="pre">wrap()</span></code><a class="headerlink" href="#wrap" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">PageElement.wrap()</span></code> обертывает элемент в указанный вами тег. Он
возвращает новую обертку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;I wish I was bold.&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="c1"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">)</span>
<span class="c1"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span>
</pre></div>
</div>
<p>Это новый метод в Beautiful Soup 4.0.5.</p>
</div>
<div class="section" id="unwrap">
<h2><code class="docutils literal notranslate"><span class="pre">unwrap()</span></code><a class="headerlink" href="#unwrap" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tag.unwrap()</span></code> — это противоположность <code class="docutils literal notranslate"><span class="pre">wrap()</span></code>. Он заменяет весь тег на
его содержимое. Этим методом удобно очищать разметку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">a_tag</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span>

<span class="n">a_tag</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span>
<span class="n">a_tag</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to example.com&lt;/a&gt;</span>
</pre></div>
</div>
<p>Как и <code class="docutils literal notranslate"><span class="pre">replace_with()</span></code>, <code class="docutils literal notranslate"><span class="pre">unwrap()</span></code> возвращает тег,
который был заменен.</p>
</div>
<div class="section" id="smooth">
<h2><code class="docutils literal notranslate"><span class="pre">smooth()</span></code><a class="headerlink" href="#smooth" title="Permalink to this headline">¶</a></h2>
<p>После вызова ряда методов, которые изменяют дерево разбора, у вас может оказаться несколько объектов <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> подряд. У Beautiful Soup с этим нет проблем, но поскольку такое не случается со свежеразобранным документом, вам может показаться неожиданным следующее поведение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;A one&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, a two&quot;</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;A one&#39;, u&#39;, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;A one, a two&lt;/p&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one</span>
<span class="c1">#  , a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p>Вы можете вызвать <code class="docutils literal notranslate"><span class="pre">Tag.smooth()</span></code>, чтобы очистить дерево разбора путем объединения смежных строк:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">contents</span>
<span class="c1"># [u&#39;A one, a two&#39;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;p&gt;</span>
<span class="c1">#  A one, a two</span>
<span class="c1"># &lt;/p&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth()</span></code> — это новый метод в Beautiful Soup 4.8.0.</p>
</div>
</div>
<div class="section" id="id46">
<h1>Вывод<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h1>
<div class="section" id="prettyprinting">
<span id="id47"></span><h2>Красивое форматирование<a class="headerlink" href="#prettyprinting" title="Permalink to this headline">¶</a></h2>
<p>Метод <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> превратит дерево разбора Beautiful Soup в
красиво отформатированную строку Unicode, где каждый
тег и каждая строка выводятся на отдельной строчке:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">()</span>
<span class="c1"># &#39;&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href=&quot;http://example.com/&quot;&gt;\n...&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#    I linked to</span>
<span class="c1">#    &lt;i&gt;</span>
<span class="c1">#     example.com</span>
<span class="c1">#    &lt;/i&gt;</span>
<span class="c1">#   &lt;/a&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Вы можете вызвать <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> верхнего уровня
или для любого из его объектов <code class="docutils literal notranslate"><span class="pre">Tag</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a href=&quot;http://example.com/&quot;&gt;</span>
<span class="c1">#  I linked to</span>
<span class="c1">#  &lt;i&gt;</span>
<span class="c1">#   example.com</span>
<span class="c1">#  &lt;/i&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>Без красивого форматирования<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>Если вам нужна просто строка, без особого форматирования, вы можете вызвать
<code class="docutils literal notranslate"><span class="pre">unicode()</span></code> или <code class="docutils literal notranslate"><span class="pre">str()</span></code> для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или объекта <code class="docutils literal notranslate"><span class="pre">Tag</span></code>
внутри:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span>

<span class="n">unicode</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># u&#39;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#39;</span>
</pre></div>
</div>
<p>Функция <code class="docutils literal notranslate"><span class="pre">str()</span></code> возвращает строку, кодированную в UTF-8. Для получения более подробной информации см.
<a class="reference internal" href="#id52">Кодировки</a>.</p>
<p>Вы также можете вызвать <code class="docutils literal notranslate"><span class="pre">encode()</span></code> для получения байтовой строки, и <code class="docutils literal notranslate"><span class="pre">decode()</span></code>,
чтобы получить Unicode.</p>
</div>
<div class="section" id="output-formatters">
<span id="id49"></span><h2>Средства форматирования вывода<a class="headerlink" href="#output-formatters" title="Permalink to this headline">¶</a></h2>
<p>Если вы дадите Beautiful Soup документ, который содержит HTML-мнемоники, такие как
“&amp;lquot;”, они будут преобразованы в символы Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;</span><span class="p">)</span>
<span class="n">unicode</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># u&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
<p>Если затем преобразовать документ в строку, символы Unicode
будет кодироваться как UTF-8. Вы не получите обратно HTML-мнемоники:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">str</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
<span class="c1"># &#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;&#39;</span>
</pre></div>
</div>
<p>По умолчанию единственные символы, которые экранируются при выводе — это чистые
амперсанды и угловые скобки. Они превращаются в «&amp;», «&lt;»
и “&gt;”, чтобы Beautiful Soup случайно не сгенерировал
невалидный HTML или XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;The law firm of Dewey, Cheatem, &amp; Howe&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="c1"># &lt;p&gt;The law firm of Dewey, Cheatem, &amp;amp; Howe&lt;/p&gt;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;amp;bar=val2&quot;&gt;A link&lt;/a&gt;</span>
</pre></div>
</div>
<p>Вы можете изменить это поведение, указав для
аргумента <code class="docutils literal notranslate"><span class="pre">formatter</span></code> одно из значений: <code class="docutils literal notranslate"><span class="pre">prettify()</span></code>, <code class="docutils literal notranslate"><span class="pre">encode()</span></code> или
<code class="docutils literal notranslate"><span class="pre">decode()</span></code>. Beautiful Soup распознает пять возможных значений
<code class="docutils literal notranslate"><span class="pre">formatter</span></code>.</p>
<p>Значение по умолчанию — <code class="docutils literal notranslate"><span class="pre">formatter=&quot;minimal&quot;</span></code>. Строки будут обрабатываться
ровно настолько, чтобы Beautiful Soup генерировал валидный HTML / XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">french</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">french</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;minimal&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &amp;lt;&amp;lt;Sacré bleu!&amp;gt;&amp;gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передадите <code class="docutils literal notranslate"><span class="pre">formatter</span> <span class="pre">=</span> <span class="pre">&quot;html&quot;</span></code>, Beautiful Soup преобразует
символы Unicode в HTML-мнемоники, когда это возможно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передаете <code class="docutils literal notranslate"><span class="pre">formatter=&quot;html5&quot;</span></code>, это то же самое, что
<code class="docutils literal notranslate"><span class="pre">formatter=&quot;html&quot;</span></code>, только Beautiful Soup будет
пропускать закрывающую косую черту в пустых тегах HTML, таких как “br”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;html5&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Если вы передадите <code class="docutils literal notranslate"><span class="pre">formatter=None</span></code>, Beautiful Soup вообще не будет менять
строки на выходе. Это самый быстрый вариант, но он может привести
к тому, что Beautiful Soup будет генерировать невалидный HTML / XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Il a dit &lt;&lt;Sacré bleu!&gt;&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>

<span class="n">link_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;</span>
</pre></div>
</div>
<p>Если вам нужен более сложный контроль над выводом, вы можете
использовать класс <code class="docutils literal notranslate"><span class="pre">Formatter</span></code> из Beautiful Soup. Вот как можно
преобразовать строки в верхний регистр, независимо от того, находятся ли они в текстовом узле или в
значении атрибута:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4.formatter</span> <span class="k">import</span> <span class="n">HTMLFormatter</span>
<span class="k">def</span> <span class="nf">uppercase</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">HTMLFormatter</span><span class="p">(</span><span class="n">uppercase</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    IL A DIT &lt;&lt;SACRÉ BLEU!&gt;&gt;</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">link_soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">))</span>
<span class="c1"># &lt;a href=&quot;HTTP://EXAMPLE.COM/?FOO=VAL1&amp;BAR=VAL2&quot;&gt;</span>
<span class="c1">#  A LINK</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
<p>Подклассы <code class="docutils literal notranslate"><span class="pre">HTMLFormatter</span></code> или <code class="docutils literal notranslate"><span class="pre">XMLFormatter</span></code> дают еще
больший контроль над выводом. Например, Beautiful Soup сортирует
атрибуты в каждом теге по умолчанию:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">attr_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">b</span><span class="s1">&#39;&lt;p z=&quot;1&quot; m=&quot;2&quot; a=&quot;3&quot;&gt;&lt;/p&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># &lt;p a=&quot;3&quot; m=&quot;2&quot; z=&quot;1&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Чтобы выключить сортировку по умолчанию, вы можете создать подкласс  на основе метода <code class="docutils literal notranslate"><span class="pre">Formatter.attributes()</span></code>,
который контролирует, какие атрибуты выводятся и в каком
порядке. Эта реализация также отфильтровывает атрибут с именем “m”,
где бы он ни появился:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UnsortedAttributes</span><span class="p">(</span><span class="n">HTMLFormatter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="n">UnsortedAttributes</span><span class="p">()))</span>
<span class="c1"># &lt;p z=&quot;1&quot; a=&quot;3&quot;&gt;&lt;/p&gt;</span>
</pre></div>
</div>
<p>Последнее предостережение: если вы создаете объект <code class="docutils literal notranslate"><span class="pre">CData</span></code>, текст внутри
этого объекта всегда представлен <cite>как есть, без какого-либо
форматирования</cite>. Beautiful Soup вызовет вашу функцию для замены мнемоник,
на тот случай, если вы написали функцию, которая подсчитывает
все строки в документе или что-то еще, но он будет игнорировать
возвращаемое значение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4.element</span> <span class="k">import</span> <span class="n">CData</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">CData</span><span class="p">(</span><span class="s2">&quot;one &lt; three&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">))</span>
<span class="c1"># &lt;a&gt;</span>
<span class="c1">#  &lt;![CDATA[one &lt; three]]&gt;</span>
<span class="c1"># &lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="get-text">
<h2><code class="docutils literal notranslate"><span class="pre">get_text()</span></code><a class="headerlink" href="#get-text" title="Permalink to this headline">¶</a></h2>
<p>Если вам нужна только текстовая часть документа или тега, вы можете использовать
метод <code class="docutils literal notranslate"><span class="pre">get_text()</span></code>. Он возвращает весь текст документа или
тега в виде единственной строки Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s1">&#39;&lt;a href=&quot;http://example.com/&quot;&gt;</span><span class="se">\n</span><span class="s1">I linked to &lt;i&gt;example.com&lt;/i&gt;</span><span class="se">\n</span><span class="s1">&lt;/a&gt;&#39;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>

<span class="n">soup</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="s1">u&#39;</span><span class="se">\n</span><span class="s1">I linked to example.com</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="s1">u&#39;example.com&#39;</span>
</pre></div>
</div>
<p>Вы можете указать строку, которая будет использоваться для объединения текстовых фрагментов
в единую строку:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c1"># soup.get_text(&quot;|&quot;)</span>
<span class="s1">u&#39;</span><span class="se">\n</span><span class="s1">I linked to |example.com|</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>Вы можете сказать Beautiful Soup удалять пробелы в начале и
конце каждого текстового фрагмента:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c1"># soup.get_text(&quot;|&quot;, strip=True)</span>
<span class="s1">u&#39;I linked to|example.com&#39;</span>
</pre></div>
</div>
<p>Но в этом случае вы можете предпочесть использовать генератор <a class="reference internal" href="#string-generators"><span class="std std-ref">.stripped_strings</span></a>
и затем обработать текст самостоятельно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="p">[</span><span class="n">text</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">]</span>
<span class="c1"># [u&#39;I linked to&#39;, u&#39;example.com&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id50">
<h1>Указание парсера<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h1>
<p>Если вам нужно просто разобрать HTML, вы можете скинуть разметку в
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>, и, скорее всего, все будет в порядке. Beautiful
Soup подберет для вас парсер и проанализирует данные. Но есть
несколько дополнительных аргументов, которые вы можете передать конструктору, чтобы изменить
используемый парсер.</p>
<p>Первым аргументом конструктора <code class="docutils literal notranslate"><span class="pre">BeautifulSou</span></code> является строка или
открытый дескриптор файла — сама разметка, которую вы хотите разобрать. Второй аргумент — это
<cite>как</cite> вы хотите, чтобы разметка была разобрана.</p>
<p>Если вы ничего не укажете, будет использован лучший HTML-парсер из тех,
которые установлены. Beautiful Soup оценивает парсер lxml как лучший, за ним идет
html5lib, затем встроенный парсер Python. Вы можете переопределить используемый парсер,
указав что-то из следующего:</p>
<ul class="simple">
<li>Какой тип разметки вы хотите разобрать. В данный момент поддерживаются:
“html”, “xml” и “html5”.</li>
<li>Имя библиотеки парсера, которую вы хотите использовать. В данный момент поддерживаются
“lxml”, “html5lib” и “html.parser” (встроенный в Python
парсер HTML).</li>
</ul>
<p>В разделе <a class="reference internal" href="#id10">Установка парсера</a> вы найдете сравнительную таблицу поддерживаемых парсеров.</p>
<p>Если у вас не установлен соответствующий парсер, Beautiful Soup
проигнорирует ваш запрос и выберет другой парсер. На текущий момент единственный
поддерживаемый парсер XML — это lxml. Если у вас не установлен lxml, запрос на
парсер XML ничего не даст, и запрос “lxml” тоже
не сработает.</p>
<div class="section" id="id51">
<h2>Различия между парсерами<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup представляет один интерфейс для разных
парсеров, но парсеры неодинаковы. Разные парсеры создадут
различные деревья разбора из одного и того же документа. Самые большие различия будут
между парсерами HTML и парсерами XML. Вот короткий
документ, разобранный как HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Поскольку пустой тег &lt;b /&gt; не является валидным кодом HTML, парсер превращает его в
пару тегов &lt;b&gt;&lt;/b&gt;.</p>
<p>Вот тот же документ, который разобран как XML (для его запуска нужно, чтобы был
установлен lxml). Обратите внимание, что пустой тег &lt;b /&gt; остается, и
что в документ добавляется объявление XML вместо
тега &lt;html&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
<span class="c1"># &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="c1"># &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>Есть также различия между парсерами HTML. Если вы даете Beautiful
Soup идеально оформленный документ HTML, эти различия не будут
иметь значения. Один парсер будет быстрее другого, но все они будут давать
структуру данных, которая выглядит точно так же, как оригинальный
документ HTML.</p>
<p>Но если документ оформлен неидеально, различные парсеры
дадут разные результаты. Вот короткий невалидный документ, разобранный с помощью
HTML-парсера lxml. Обратите внимание, что висячий тег &lt;/p&gt; просто
игнорируется:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Вот тот же документ, разобранный с помощью html5lib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html5lib&quot;</span><span class="p">)</span>
<span class="c1"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre></div>
</div>
<p>Вместо того, чтобы игнорировать висячий тег &lt;/p&gt;, html5lib добавляет
открывающй тег &lt;p&gt;. Этот парсер также добавляет пустой тег &lt;head&gt; в
документ.</p>
<p>Вот тот же документ, разобранный с помощью встроенного в Python
парсера HTML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&lt;a&gt;&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
<span class="c1"># &lt;a&gt;&lt;/a&gt;</span>
</pre></div>
</div>
<p>Как и html5lib, этот парсер игнорирует закрывающий тег &lt;/p&gt;. В отличие от
html5lib, этот парсер не делает попытки создать правильно оформленный HTML-
документ, добавив тег &lt;body&gt;. В отличие от lxml, он даже не
добавляет тег &lt;html&gt;.</p>
<p>Поскольку документ <code class="docutils literal notranslate"><span class="pre">&lt;a&gt;&lt;/p&gt;</span></code> невалиден, ни один из этих способов
нельзя назвать “правильным”. Парсер html5lib использует способы,
которые являются частью стандарта HTML5, поэтому он может претендовать на то, что его подход
самый “правильный”, но правомерно использовать любой из трех методов.</p>
<p>Различия между парсерами могут повлиять на ваш скрипт. Если вы планируете
распространять ваш скрипт или запускать его на нескольких
машинах, вам нужно указать парсер в
конструкторе <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Это уменьшит вероятность того, что ваши пользователи при разборе
документа получат результат, отличный от вашего.</p>
</div>
</div>
<div class="section" id="id52">
<h1>Кодировки<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h1>
<p>Любой документ HTML или XML написан в определенной кодировке, такой как ASCII
или UTF-8.  Но когда вы загрузите этот документ в Beautiful Soup, вы
обнаружите, что он был преобразован в Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;h1&gt;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="c1"># &lt;h1&gt;Sacré bleu!&lt;/h1&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">string</span>
<span class="c1"># u&#39;Sacr\xe9 bleu!&#39;</span>
</pre></div>
</div>
<p>Это не волшебство. (Хотя это было бы здорово, конечно.) Beautiful Soup использует
подбиблиотеку под названием <a class="reference internal" href="#unicode-dammit">Unicode, Dammit</a> для определения кодировки документа
и преобразования ее в Unicode. Кодировка, которая была автоматически определена, содержится в значении
атрибута <code class="docutils literal notranslate"><span class="pre">.original_encoding</span></code> объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;utf-8&#39;</span>
</pre></div>
</div>
<p>Unicode, Dammit чаще всего угадывает правильно, но иногда
делает ошибки. Иногда он угадывает правильно только после
побайтового поиска по документу, что занимает очень много времени. Если
вы вдруг уже знаете кодировку документа, вы можете избежать
ошибок и задержек, передав кодировку конструктору <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>
как аргумент <code class="docutils literal notranslate"><span class="pre">from_encoding</span></code>.</p>
<p>Вот документ, написанный на ISO-8859-8. Документ настолько короткий, что
Unicode, Dammit не может разобраться и неправильно идентифицирует кодировку как
ISO-8859-7:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="n">b</span><span class="s2">&quot;&lt;h1&gt;</span><span class="se">\xed\xe5\xec\xf9</span><span class="s2">&lt;/h1&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">νεμω</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;ISO-8859-7&#39;</span>
</pre></div>
</div>
<p>Мы можем все исправить, передав правильный <code class="docutils literal notranslate"><span class="pre">from_encoding</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="n">from_encoding</span><span class="o">=</span><span class="s2">&quot;iso-8859-8&quot;</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">םולש</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;iso8859-8&#39;</span>
</pre></div>
</div>
<p>Если вы не знаете правильную кодировку, но видите, что
Unicode, Dammit определяет ее неправильно, вы можете передать ошибочные варианты в
<code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="n">exclude_encodings</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ISO-8859-7&quot;</span><span class="p">])</span>
<span class="n">soup</span><span class="o">.</span><span class="n">h1</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">םולש</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">soup</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="s1">&#39;WINDOWS-1255&#39;</span>
</pre></div>
</div>
<p>Windows-1255 не на 100% подходит, но это совместимое
надмножество ISO-8859-8, так что догадка почти верна. (<code class="docutils literal notranslate"><span class="pre">exclude_encodings</span></code>
— это новая функция в Beautiful Soup 4.4.0.)</p>
<p>В редких случаях (обычно когда документ UTF-8 содержит текст в
совершенно другой кодировке) единственным способом получить Unicode может оказаться
замена некоторых символов специальным символом Unicode
“REPLACEMENT CHARACTER” (U+FFFD, �). Если Unicode, Dammit приходится это сделать,
он установит атрибут <code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code>
в <code class="docutils literal notranslate"><span class="pre">True</span></code> для объектов <code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code> или <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. Это
даст понять, что представление в виде Unicode не является точным
представление оригинала, и что некоторые данные потерялись. Если документ
содержит �, но <code class="docutils literal notranslate"><span class="pre">.contains_replacement_characters</span></code> равен <code class="docutils literal notranslate"><span class="pre">False</span></code>,
вы будете знать, что � был в тексте изначально (как в этом
параграфе), а не служит заменой отсутствующим данным.</p>
<div class="section" id="id53">
<h2>Кодировка вывода<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h2>
<p>Когда вы пишете документ из Beautiful Soup, вы получаете документ в UTF-8,
даже если он изначально не был в UTF-8. Вот
документ в кодировке Latin-1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="n">b</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1"> &lt;html&gt;</span>
<span class="s1">  &lt;head&gt;</span>
<span class="s1">   &lt;meta content=&quot;text/html; charset=ISO-Latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="s1">  &lt;/head&gt;</span>
<span class="s1">  &lt;body&gt;</span>
<span class="s1">   &lt;p&gt;Sacr</span><span class="se">\xe9</span><span class="s1"> bleu!&lt;/p&gt;</span>
<span class="s1">  &lt;/body&gt;</span>
<span class="s1"> &lt;/html&gt;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1">#  &lt;/head&gt;</span>
<span class="c1">#  &lt;body&gt;</span>
<span class="c1">#   &lt;p&gt;</span>
<span class="c1">#    Sacré bleu!</span>
<span class="c1">#   &lt;/p&gt;</span>
<span class="c1">#  &lt;/body&gt;</span>
<span class="c1"># &lt;/html&gt;</span>
</pre></div>
</div>
<p>Обратите внимание, что тег &lt;meta&gt; был переписан, чтобы отразить тот факт, что
теперь документ кодируется в UTF-8.</p>
<p>Если вы не хотите кодировку UTF-8, вы можете передать другую в <code class="docutils literal notranslate"><span class="pre">prettify()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">prettify</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">))</span>
<span class="c1"># &lt;html&gt;</span>
<span class="c1">#  &lt;head&gt;</span>
<span class="c1">#   &lt;meta content=&quot;text/html; charset=latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>Вы также можете вызвать encode() для объекта <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или любого
элемента в супе, как если бы это была строка Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">)</span>
<span class="c1"># &#39;&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;&#39;</span>

<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="c1"># &#39;&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>Любые символы, которые не могут быть представлены в выбранной вами кодировке, будут
преобразованы в числовые коды мнемоник XML. Вот документ,
который включает в себя Unicode-символ SNOWMAN (снеговик):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">u&quot;&lt;b&gt;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&lt;/b&gt;&quot;</span>
<span class="n">snowman_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">)</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">snowman_soup</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>Символ SNOWMAN может быть частью документа UTF-8 (он выглядит
так: ☃), но в ISO-Latin-1 или
ASCII нет представления для этого символа, поэтому для этих кодировок он конвертируется в “&amp;#9731;”:</p>
<blockquote>
<div><p>print(tag.encode(“utf-8”))
# &lt;b&gt;☃&lt;/b&gt;</p>
<p>print tag.encode(“latin-1”)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;</p>
<p>print tag.encode(“ascii”)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;</p>
</div></blockquote>
</div>
<div class="section" id="unicode-dammit">
<h2>Unicode, Dammit<a class="headerlink" href="#unicode-dammit" title="Permalink to this headline">¶</a></h2>
<p>Вы можете использовать Unicode, Dammit без Beautiful Soup. Он полезен в тех случаях.
когда у вас есть данные в неизвестной кодировке, и вы просто хотите, чтобы они
преобразовались в Unicode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">UnicodeDammit</span>
<span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">&quot;Sacr</span><span class="se">\xc3\xa9</span><span class="s2"> bleu!&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># Sacré bleu!</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;utf-8&#39;</span>
</pre></div>
</div>
<p>Догадки Unicode, Dammit станут намного точнее, если вы установите
библиотеки Python <code class="docutils literal notranslate"><span class="pre">chardet</span></code> или <code class="docutils literal notranslate"><span class="pre">cchardet</span></code>. Чем больше данных вы
даете Unicode, Dammit, тем точнее он определит кодировку. Если у вас есть
собственные предположения относительно возможных кодировок, вы можете передать
их в виде списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">dammit</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="p">(</span><span class="s2">&quot;Sacr</span><span class="se">\xe9</span><span class="s2"> bleu!&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;latin-1&quot;</span><span class="p">,</span> <span class="s2">&quot;iso-8859-1&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dammit</span><span class="o">.</span><span class="n">unicode_markup</span><span class="p">)</span>
<span class="c1"># Sacré bleu!</span>
<span class="n">dammit</span><span class="o">.</span><span class="n">original_encoding</span>
<span class="c1"># &#39;latin-1&#39;</span>
</pre></div>
</div>
<p>В Unicode, Dammit есть две специальные функции, которые Beautiful Soup не
использует.</p>
<div class="section" id="id54">
<h3>Парные кавычки<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h3>
<p>Вы можете использовать Unicode, Dammit, чтобы конвертировать парные кавычки (Microsoft smart quotes) в
мнемоники HTML или XML:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="n">b</span><span class="s2">&quot;&lt;p&gt;I just </span><span class="se">\x93</span><span class="s2">love</span><span class="se">\x94</span><span class="s2"> Microsoft Word</span><span class="se">\x92</span><span class="s2">s smart quotes&lt;/p&gt;&quot;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;&#39;</span>

<span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;xml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>Вы также можете конвертировать парные кавычки в обычные кавычки ASCII:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">],</span> <span class="n">smart_quotes_to</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just &quot;love&quot; Microsoft Word\&#39;s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
<p>Надеюсь, вы найдете эту функцию полезной, но Beautiful Soup не
использует ее. Beautiful Soup по умолчанию
конвертирует парные кавычки в символы Unicode, как и
все остальное:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">UnicodeDammit</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">unicode_markup</span>
<span class="c1"># u&#39;&lt;p&gt;I just \u201clove\u201d Microsoft Word\u2019s smart quotes&lt;/p&gt;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id55">
<h3>Несогласованные кодировки<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
<p>Иногда документ кодирован в основном в UTF-8, но содержит символы Windows-1252,
такие как, опять-таки, парные кавычки. Такое бывает,
когда веб-сайт содержит данные из нескольких источников. Вы можете использовать
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code>, чтобы превратить такой документ в чистый
UTF-8. Вот простой пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">snowmen</span> <span class="o">=</span> <span class="p">(</span><span class="s2">u&quot;</span><span class="se">\N{SNOWMAN}</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">quote</span> <span class="o">=</span> <span class="p">(</span><span class="s2">u&quot;</span><span class="se">\N{LEFT DOUBLE QUOTATION MARK}</span><span class="s2">I like snowmen!</span><span class="se">\N{RIGHT DOUBLE QUOTATION MARK}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">snowmen</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">quote</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;windows_1252&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>В этом документе бардак. Снеговики в UTF-8, а парные кавычки
в Windows-1252. Можно отображать или снеговиков, или кавычки, но не
то и другое одновременно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="c1"># ☃☃☃�I like snowmen!�</span>

<span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;windows-1252&quot;</span><span class="p">))</span>
<span class="c1"># â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</span>
</pre></div>
</div>
<p>Декодирование документа как UTF-8 вызывает <code class="docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code>, а
декодирование его как Windows-1252 выдаст тарабарщину. К счастью,
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> преобразует строку в чистый UTF-8,
позволяя затем декодировать его в Unicode и отображать снеговиков и кавычки
одновременно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">new_doc</span> <span class="o">=</span> <span class="n">UnicodeDammit</span><span class="o">.</span><span class="n">detwingle</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span>
<span class="c1"># ☃☃☃“I like snowmen!”</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> знает только, как обрабатывать Windows-1252,
встроенный в UTF-8 (и наоборот, мне кажется), но это наиболее
общий случай.</p>
<p>Обратите внимание, что нужно вызывать <code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> для ваших данных
перед передачей в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> или
<code class="docutils literal notranslate"><span class="pre">UnicodeDammit</span></code>. Beautiful Soup предполагает, что документ имеет единую
кодировку, какой бы она ни была. Если вы передадите ему документ, который
содержит как UTF-8, так и Windows-1252, скорее всего, он решит, что весь
документ кодируется в Windows-1252, и это будет выглядеть как
<code class="docutils literal notranslate"><span class="pre">â˜ƒâ˜ƒâ˜ƒ“I</span> <span class="pre">like</span> <span class="pre">snowmen!”</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.detwingle()</span></code> — это новое в Beautiful Soup 4.1.0.</p>
</div>
</div>
</div>
<div class="section" id="id56">
<h1>Нумерация строк<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h1>
<p>Парсеры <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> и <code class="docutils literal notranslate"><span class="pre">html5lib</span></code> могут отслеживать, где в
исходном документе был найден каждый тег. Вы можете получить доступ к этой
информации через <code class="docutils literal notranslate"><span class="pre">Tag.sourceline</span></code> (номер строки) и <code class="docutils literal notranslate"><span class="pre">Tag.sourcepos</span></code>
(позиция начального тега в строке):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># (1, 0, u&#39;Paragraph 1&#39;)</span>
<span class="c1"># (2, 3, u&#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>Обратите внимание, что два парсера понимают
<code class="docutils literal notranslate"><span class="pre">sourceline</span></code> и <code class="docutils literal notranslate"><span class="pre">sourcepos</span></code> немного по-разному. Для html.parser эти числа
представляет позицию начального знака “&lt;”. Для html5lib
эти числа представляют позицию конечного знака “&gt;”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html5lib&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">sourceline</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">sourcepos</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1"># (2, 1, u&#39;Paragraph 1&#39;)</span>
<span class="c1"># (3, 7, u&#39;Paragraph 2&#39;)</span>
</pre></div>
</div>
<p>Вы можете отключить эту функцию, передав <code class="docutils literal notranslate"><span class="pre">store_line_numbers</span> <span class="pre">=</span> <span class="pre">False</span></code>
в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p</span><span class="se">\n</span><span class="s2">&gt;Paragraph 1&lt;/p&gt;</span><span class="se">\n</span><span class="s2">    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">,</span> <span class="n">store_line_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">sourceline</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Эта функция является новой в 4.8.1, и парсеры, основанные на lxml, не
поддерживают ее.</p>
</div>
<div class="section" id="id57">
<h1>Проверка объектов на равенство<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup считает, что два объекта <code class="docutils literal notranslate"><span class="pre">NavigableString</span></code> или <code class="docutils literal notranslate"><span class="pre">Tag</span></code>
равны, если они представлены в одинаковой разметке HTML или XML. В этом
примере два тега &lt;b&gt; рассматриваются как равные, даже если они находятся
в разных частях дерева объекта, потому что они оба выглядят как
<code class="docutils literal notranslate"><span class="pre">&lt;b&gt;pizza&lt;/b&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">markup</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="n">first_b</span><span class="p">,</span> <span class="n">second_b</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">first_b</span> <span class="o">==</span> <span class="n">second_b</span>
<span class="c1"># True</span>

<span class="nb">print</span> <span class="n">first_b</span><span class="o">.</span><span class="n">previous_element</span> <span class="o">==</span> <span class="n">second_b</span><span class="o">.</span><span class="n">previous_element</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>Если вы хотите выяснить, указывают ли две переменные на один и тот же
объект, используйте <cite>is</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span> <span class="n">first_b</span> <span class="ow">is</span> <span class="n">second_b</span>
<span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="section" id="id58">
<h1>Копирование объектов Beautiful Soup<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h1>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">copy.copy()</span></code> для создания копии любого <code class="docutils literal notranslate"><span class="pre">Tag</span></code> или
<code class="docutils literal notranslate"><span class="pre">NavigableString</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">p_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">p_copy</span>
<span class="c1"># &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</span>
</pre></div>
</div>
<p>Копия считается равной оригиналу, так как у нее
такая же разметка, что и у оригинала, но это другой объект:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">p_copy</span>
<span class="c1"># True</span>

<span class="nb">print</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span> <span class="ow">is</span> <span class="n">p_copy</span>
<span class="c1"># False</span>
</pre></div>
</div>
<p>Единственная настоящая разница в том, что копия полностью отделена от
исходного дерева объекта Beautiful Soup, как если бы в отношении нее вызвали
метод  <code class="docutils literal notranslate"><span class="pre">extract()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="nb">print</span> <span class="n">p_copy</span><span class="o">.</span><span class="n">parent</span>
<span class="c1"># None</span>
</pre></div>
</div>
<p>Это потому, что два разных объекта <code class="docutils literal notranslate"><span class="pre">Tag</span></code> не могут занимать одно и то же
пространство в одно и то же время.</p>
</div>
<div class="section" id="id59">
<h1>Разбор части документа<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h1>
<p>Допустим, вы хотите использовать Beautiful Soup, чтобы посмотреть на
теги &lt;a&gt; в документе. Было бы бесполезной тратой времени и памяти разобирать весь документ и
затем снова проходить по нему в поисках тегов &lt;a&gt;. Намного быстрее
изначательно игнорировать все, что не является тегом &lt;a&gt;. Класс
<code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> позволяет выбрать, какие части входящего
документ разбирать. Вы просто создаете <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> и передаете его в
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> в качестве аргумента <code class="docutils literal notranslate"><span class="pre">parse_only</span></code>.</p>
<p>(Обратите внимание, что <em>эта функция не будет работать, если вы используете парсер html5lib</em>.
Если вы используете html5lib, будет разобран весь документ, независимо
от обстоятельств. Это потому что html5lib постоянно переставляет части дерева разбора
в процессе работы, и если какая-то часть документа не
попала в дерево разбора, все рухнет. Чтобы избежать путаницы, в
примерах ниже я принудительно использую встроенный в Python
парсер HTML.)</p>
<div class="section" id="soupstrainer">
<h2><code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code><a class="headerlink" href="#soupstrainer" title="Permalink to this headline">¶</a></h2>
<p>Класс <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> принимает те же аргументы, что и типичный
метод из раздела <a class="reference internal" href="#id27">Поиск по дереву</a>: <a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, <a class="reference internal" href="#attrs"><span class="std std-ref">attrs</span></a>, <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a> и <a class="reference internal" href="#kwargs"><span class="std std-ref">**kwargs</span></a>. Вот
три объекта <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">SoupStrainer</span>

<span class="n">only_a_tags</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

<span class="n">only_tags_with_id_link2</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;link2&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_short_string</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>

<span class="n">only_short_strings</span> <span class="o">=</span> <span class="n">SoupStrainer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">is_short_string</span><span class="p">)</span>
</pre></div>
</div>
<p>Вернемся к фрагменту из «Алисы в стране чудес»
и увидим, как выглядит документ, когда он разобран с этими
тремя объектами <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">html_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;</span>
<span class="s2">&lt;body&gt;</span>
<span class="s2">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span>
<span class="s2">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span>
<span class="s2">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span>
<span class="s2">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span>
<span class="s2">and they lived at the bottom of a well.&lt;/p&gt;</span>

<span class="s2">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_a_tags</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span>
<span class="c1">#  Elsie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span>
<span class="c1">#  Tillie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_tags_with_id_link2</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span>
<span class="c1">#  Lacie</span>
<span class="c1"># &lt;/a&gt;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">,</span> <span class="n">parse_only</span><span class="o">=</span><span class="n">only_short_strings</span><span class="p">)</span><span class="o">.</span><span class="n">prettify</span><span class="p">())</span>
<span class="c1"># Elsie</span>
<span class="c1"># ,</span>
<span class="c1"># Lacie</span>
<span class="c1"># and</span>
<span class="c1"># Tillie</span>
<span class="c1"># ...</span>
<span class="c1">#</span>
</pre></div>
</div>
<p>Вы также можете передать <code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code> в любой из методов. описанных в разделе
<a class="reference internal" href="#id27">Поиск по дереву</a>. Может, это не безумно полезно, но я
решил упомянуть:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html_doc</span><span class="p">)</span>
<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">only_short_strings</span><span class="p">)</span>
<span class="c1"># [u&#39;\n\n&#39;, u&#39;\n\n&#39;, u&#39;Elsie&#39;, u&#39;,\n&#39;, u&#39;Lacie&#39;, u&#39; and\n&#39;, u&#39;Tillie&#39;,</span>
<span class="c1">#  u&#39;\n\n&#39;, u&#39;...&#39;, u&#39;\n&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id60">
<h1>Устранение неисправностей<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h1>
<div class="section" id="diagnose">
<span id="id61"></span><h2><code class="docutils literal notranslate"><span class="pre">diagnose()</span></code><a class="headerlink" href="#diagnose" title="Permalink to this headline">¶</a></h2>
<p>Если у вас возникли проблемы с пониманием того, что Beautiful Soup делает с
документом, передайте документ в функцию <code class="docutils literal notranslate"><span class="pre">Diagnose()</span></code>. (Новое в
Beautiful Soup 4.2.0.)  Beautiful Soup выведет отчет, показывающий,
как разные парсеры обрабатывают документ, и сообщит вам, если
отсутствует парсер, который Beautiful Soup мог бы использовать:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4.diagnose</span> <span class="k">import</span> <span class="n">diagnose</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;bad.html&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">diagnose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Diagnostic running on Beautiful Soup 4.2.0</span>
<span class="c1"># Python version 2.7.3 (default, Aug  1 2012, 05:16:07)</span>
<span class="c1"># I noticed that html5lib is not installed. Installing it may help.</span>
<span class="c1"># Found lxml version 2.3.2.0</span>
<span class="c1">#</span>
<span class="c1"># Trying to parse your data with html.parser</span>
<span class="c1"># Here&#39;s what html.parser did with the document:</span>
<span class="c1"># ...</span>
</pre></div>
</div>
<p>Простой взгляд на вывод diagnose() может показать, как решить
проблему. Если это и не поможет, вы можете скопировать вывод <code class="docutils literal notranslate"><span class="pre">Diagnose()</span></code>, когда
обратитесь за помощью.</p>
</div>
<div class="section" id="id62">
<h2>Ошибки при разборе документа<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h2>
<p>Существует два вида ошибок разбора. Есть сбои,
когда вы подаете документ в Beautiful Soup, и это поднимает
исключение, обычно <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError</span></code>. И есть
неожиданное поведение, когда дерево разбора Beautiful Soup сильно
отличается от документа, использованного для создания дерева.</p>
<p>Практически никогда источником этих проблемы не бывает Beautiful
Soup. Это не потому, что Beautiful Soup так прекрасно
написан. Это потому, что Beautiful Soup не содержит
кода, который бы разбирал документ. Beautiful Soup опирается на внешние парсеры. Если один парсер
не подходит для разбора документа, лучшим решением будет попробовать
другой парсер. В разделе <a class="reference internal" href="#id10">Установка парсера</a> вы найдете больше информации
и таблицу сравнения парсеров.</p>
<p>Наиболее распространенные ошибки разбора — это <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span>
<span class="pre">malformed</span> <span class="pre">start</span> <span class="pre">tag</span></code> и <code class="docutils literal notranslate"><span class="pre">HTMLParser.HTMLParseError:</span> <span class="pre">bad</span> <span class="pre">end</span>
<span class="pre">tag</span></code>. Они оба генерируются встроенным в Python парсером HTML,
и решением будет <a class="reference internal" href="#parser-installation"><span class="std std-ref">установить lxml или
html5lib.</span></a></p>
<p>Наиболее распространенный тип неожиданного поведения — когда вы не можете найти
тег, который точно есть в документе. Вы видели его на входе, но
<code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает <code class="docutils literal notranslate"><span class="pre">[]</span></code>, или <code class="docutils literal notranslate"><span class="pre">find()</span></code> возвращает <code class="docutils literal notranslate"><span class="pre">None</span></code>. Это
еще одна распространенная проблема со встроенным в Python парсером HTML, который
иногда пропускает теги, которые он не понимает.  Опять же, решение заключается в
<a class="reference internal" href="#parser-installation"><span class="std std-ref">установке lxml или html5lib</span></a>.</p>
</div>
<div class="section" id="id63">
<h2>Проблемы несоответствия версий<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SyntaxError:</span> <span class="pre">Invalid</span> <span class="pre">syntax</span></code> (в строке <code class="docutils literal notranslate"><span class="pre">ROOT_TAG_NAME</span> <span class="pre">=</span>
<span class="pre">u'[document]'</span></code>) — вызвано запуском версии Beautiful Soup на Python 2
под Python 3 без конвертации кода.</li>
<li><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">HTMLParser</span></code> — вызвано запуском
версия Beautiful Soup на Python 3 под Python 2.</li>
<li><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">html.parser</span></code> — вызвано запуском
версия Beautiful Soup на Python 2 под Python 3.</li>
<li><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">BeautifulSoup</span></code> — вызвано запуском
кода Beautiful Soup 3 в системе, где BS3
не установлен. Или код писали на Beautiful Soup 4, не зная, что
имя пакета сменилось на <code class="docutils literal notranslate"><span class="pre">bs4</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">No</span> <span class="pre">module</span> <span class="pre">named</span> <span class="pre">bs4</span></code> — вызвано запуском
кода Beautiful Soup 4 в системе, где BS4 не установлен.</li>
</ul>
</div>
<div class="section" id="xml">
<span id="parsing-xml"></span><h2>Разбор XML<a class="headerlink" href="#xml" title="Permalink to this headline">¶</a></h2>
<p>По умолчанию Beautiful Soup разбирает документы как HTML. Чтобы разобрать
документ в виде XML, передайте “xml” в качестве второго аргумента
в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">markup</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Вам также нужно будет <a class="reference internal" href="#parser-installation"><span class="std std-ref">установить lxml</span></a>.</p>
</div>
<div class="section" id="id64">
<h2>Другие проблемы с парсерами<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Если ваш скрипт работает на одном компьютере, но не работает на другом, или работает в одной
виртуальной среде, но не в другой, или работает вне виртуальной
среды, но не внутри нее, это, вероятно, потому что в двух
средах разные библиотеки парсеров. Например,
вы могли разработать скрипт на компьютере с установленным lxml,
а затем попытались запустить его на компьютере, где установлен только
html5lib. Читайте в разделе <a class="reference internal" href="#id51">Различия между парсерами</a>, почему это
важно, и исправляйте проблемы, указывая конкретную библиотеку парсера
в конструкторе <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>.</li>
<li>Поскольку <a class="reference external" href="http://www.w3.org/TR/html5/syntax.html#syntax">HTML-теги и атрибуты нечувствительны к регистру</a>, все три HTML-
парсера конвертируют имена тегов и атрибутов в нижний регистр. Таким образом,
разметка &lt;TAG&gt;&lt;/TAG&gt; преобразуется в &lt;tag&gt;&lt;/tag&gt;. Если вы хотите
сохранить смешанный или верхний регистр тегов и атрибутов, вам нужно
<a class="reference internal" href="#parsing-xml"><span class="std std-ref">разобрать документ как XML</span></a>.</li>
</ul>
</div>
<div class="section" id="misc">
<span id="id65"></span><h2>Прочие ошибки<a class="headerlink" href="#misc" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'charmap'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span>
<span class="pre">u'\xfoo'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">bar</span></code> (или практически любая другая ошибка
<code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code>) — это не проблема с Beautiful Soup.
Эта проблема проявляется в основном в двух ситуациях. Во-первых, когда вы пытаетесь
вывести символ Unicode, который ваша консоль не может отобразить, потому что не знает, как.
(Смотрите <a class="reference external" href="http://wiki.python.org/moin/PrintFails">эту страницу в Python вики</a>.) Во-вторых, когда
вы пишете в файл и передаете символ Unicode, который
не поддерживается вашей кодировкой по умолчанию.  В этом случае самым простым
решением будет явное кодирование строки Unicode в UTF-8 с помощью
<code class="docutils literal notranslate"><span class="pre">u.encode(&quot;utf8&quot;)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">[attr]</span></code> — вызывается при обращении к <code class="docutils literal notranslate"><span class="pre">tag['attr']</span></code>, когда
в искомом теге не определен атрибут <code class="docutils literal notranslate"><span class="pre">attr</span></code>. Наиболее
типичны ошибки <code class="docutils literal notranslate"><span class="pre">KeyError:</span> <span class="pre">'href'</span></code> и <code class="docutils literal notranslate"><span class="pre">KeyError:</span>
<span class="pre">'class'</span></code>. Используйте <code class="docutils literal notranslate"><span class="pre">tag.get('attr')</span></code>, если вы не уверены, что <code class="docutils literal notranslate"><span class="pre">attr</span></code>
определен — так же, как если бы вы работали со словарем Python.</li>
<li><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'ResultSet'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> — это
обычно происходит тогда, когда вы ожидаете, что <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> вернет
один тег или строку. Но <code class="docutils literal notranslate"><span class="pre">find_all()</span></code> возвращает <em>список</em> тегов
и строк в объекте <code class="docutils literal notranslate"><span class="pre">ResultSet</span></code>. Вам нужно перебрать
список и поискать <code class="docutils literal notranslate"><span class="pre">.foo</span></code> в каждом из элементов. Или, если вам действительно
нужен только один результат, используйте <code class="docutils literal notranslate"><span class="pre">find()</span></code> вместо
<code class="docutils literal notranslate"><span class="pre">find_all()</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">AttributeError:</span> <span class="pre">'NoneType'</span> <span class="pre">object</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'foo'</span></code> — это
обычно происходит, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">find()</span></code> и затем пытаетесь
получить доступ к атрибуту <code class="docutils literal notranslate"><span class="pre">.foo</span></code>. Но в вашем случае
<code class="docutils literal notranslate"><span class="pre">find()</span></code> не нашел ничего, поэтому вернул <code class="docutils literal notranslate"><span class="pre">None</span></code> вместо
того, чтобы вернуть тег или строку. Вам нужно выяснить, почему
<code class="docutils literal notranslate"><span class="pre">find()</span></code> ничего не возвращает.</li>
</ul>
</div>
<div class="section" id="id66">
<h2>Повышение производительности<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h2>
<p>Beautiful Soup никогда не будет таким же быстрым, как парсеры, на основе которых он
работает. Если время отклика критично, если вы платите за компьютерное время
по часам, или если есть какая-то другая причина, почему компьютерное время
важнее  программистского, стоит забыть о Beautiful Soup
и работать непосредственно с <a class="reference external" href="http://lxml.de/">lxml</a>.</p>
<p>Тем не менее, есть вещи, которые вы можете сделать, чтобы ускорить Beautiful Soup. Если
вы не используете lxml в качестве основного парсера, самое время
<a class="reference internal" href="#parser-installation"><span class="std std-ref">начать</span></a>. Beautiful Soup разбирает документы
значительно быстрее с lxml, чем с html.parser или html5lib.</p>
<p>Вы можете значительно ускорить распознавание кодировок, установив
библиотеку <a class="reference external" href="http://pypi.python.org/pypi/cchardet/">cchardet</a>.</p>
<p><a class="reference internal" href="#id59">Разбор части документа</a> не сэкономит много времени в процессе разбора,
но может сэкономить много памяти, что сделает
<cite>поиск</cite> по документу намного быстрее.</p>
</div>
</div>
<div class="section" id="id68">
<h1>Beautiful Soup 3<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h1>
<p>Beautiful Soup 3 — предыдущая версия, и она больше
активно не развивается. На текущий момент Beautiful Soup 3 поставляется со всеми основными
дистрибутивами Linux:</p>
<p><kbd class="kbd docutils literal notranslate">$ apt-get install python-beautifulsoup</kbd></p>
<p>Он также публикуется через PyPi как <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>:</p>
<p><kbd class="kbd docutils literal notranslate">$ easy_install BeautifulSoup</kbd></p>
<p><kbd class="kbd docutils literal notranslate">$ pip install BeautifulSoup</kbd></p>
<p>Вы можете скачать <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz">tar-архив Beautiful Soup 3.2.0</a>.</p>
<p>Если вы запустили <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup</span></code> или <code class="docutils literal notranslate"><span class="pre">easy_install</span>
<span class="pre">BeautifulSoup</span></code>, но ваш код не работает, значит, вы ошибочно установили Beautiful
Soup 3. Вам нужно запустить <code class="docutils literal notranslate"><span class="pre">easy_install</span> <span class="pre">beautifulsoup4</span></code>.</p>
<p>Архивная документация для Beautiful Soup 3 доступна <a class="reference external" href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">онлайн</a>.</p>
<div class="section" id="bs4">
<h2>Перенос кода на BS4<a class="headerlink" href="#bs4" title="Permalink to this headline">¶</a></h2>
<p>Большая часть кода, написанного для Beautiful Soup 3, будет работать и в Beautiful
Soup 4 с одной простой заменой. Все, что вам нужно сделать, это изменить
имя пакета c <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> на <code class="docutils literal notranslate"><span class="pre">bs4</span></code>. Так что это:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">BeautifulSoup</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<p>становится этим:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bs4</span> <span class="k">import</span> <span class="n">BeautifulSoup</span>
</pre></div>
</div>
<ul class="simple">
<li>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> “No module named BeautifulSoup”, ваша
проблема в том, что вы пытаетесь запустить код Beautiful Soup 3, в то время как
у вас установлен Beautiful Soup 4.</li>
<li>Если выводится сообщение <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> “No module named bs4”, ваша проблема
в том, что вы пытаетесь запустить код Beautiful Soup 4, в то время как
у вас установлен Beautiful Soup 3.</li>
</ul>
<p>Хотя BS4 в основном обратно совместим с BS3, большинство
методов BS3 устарели и получили новые имена, чтобы <a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">соответствовать PEP 8</a>. Некоторые
из переименований и изменений нарушают обратную совместимость.</p>
<p>Вот что нужно знать, чтобы перейти с BS3 на BS4:</p>
<div class="section" id="id70">
<h3>Вам нужен парсер<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h3>
<p>Beautiful Soup 3 использовал модуль Python <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code>, который теперь
устарел и был удален в Python 3.0. Beautiful Soup 4 по умолчанию использует
<code class="docutils literal notranslate"><span class="pre">html.parser</span></code>, но вы можете подключить lxml или html5lib
вместо него. Вы найдете таблицу сравнения парсеров в разделе <a class="reference internal" href="#id10">Установка парсера</a>.</p>
<p>Поскольку <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> — это не то же, что <code class="docutils literal notranslate"><span class="pre">SGMLParser</span></code>, вы
можете обнаружить, что Beautiful Soup 4 дает другое дерево разбора, чем
Beautiful Soup 3. Если вы замените html.parser
на lxml или html5lib, может оказаться, что дерево разбора опять
изменилось. Если такое случится, вам придется обновить код,
чтобы разобраться с новым деревом.</p>
</div>
<div class="section" id="id71">
<h3>Имена методов<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">renderContents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">encode_contents</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">replaceWith</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">replace_with</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">replaceWithChildren</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">unwrap</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findAll</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findAllNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_next</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findAllPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_all_previous</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findNext</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findNextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_sibling</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findNextSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_next_siblings</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findParent</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parent</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findParents</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_parents</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findPrevious</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findPreviousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_sibling</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">findPreviousSiblings</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">find_previous_siblings</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">getText</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">get_text</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">nextSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_sibling</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">previousSibling</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_sibling</span></code></li>
</ul>
<p>Некоторые аргументы конструктора Beautiful Soup были переименованы по
той же причине:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parseOnlyThese=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(parse_only=...)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">BeautifulSoup(fromEncoding=...)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">BeautifulSoup(from_encoding=...)</span></code></li>
</ul>
<p>Я переименовал один метод для совместимости с Python 3:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Tag.has_key()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.has_attr()</span></code></li>
</ul>
<p>Я переименовал один атрибут, чтобы использовать более точную терминологию:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Tag.isSelfClosing</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.is_empty_element</span></code></li>
</ul>
<p>Я переименовал три атрибута, чтобы избежать использования зарезервированных слов
в Python. В отличие от других, эти изменения <em>не являются обратно
совместимыми</em>. Если вы использовали эти атрибуты в BS3, ваш код не сработает
на BS4, пока вы их не измените.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UnicodeDammit.unicode</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">UnicodeDammit.unicode_markup</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Tag.next</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.next_element</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Tag.previous</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Tag.previous_element</span></code></li>
</ul>
</div>
<div class="section" id="id72">
<h3>Генераторы<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h3>
<p>Я дал генераторам PEP 8-совместимые имена и преобразовал их в
свойства:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">childGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">children</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">nextGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_elements</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">nextSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">next_siblings</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">previousGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_elements</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">previousSiblingGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">previous_siblings</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">recursiveChildGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">descendants</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">parentGenerator()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">parents</span></code></li>
</ul>
<p>Так что вместо этого:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parentGenerator</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Вы можете написать это:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tag</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>(Хотя старый код тоже будет работать.)</p>
<p>Некоторые генераторы выдавали <code class="docutils literal notranslate"><span class="pre">None</span></code> после их завершения и
останавливались. Это была ошибка. Теперь генераторы просто останавливаются.</p>
<p>Добавились два генератора: <a class="reference internal" href="#string-generators"><span class="std std-ref">.strings и
.stripped_strings</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">.strings</span></code> выдает
объекты NavigableString, а <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code> выдает строки Python,
у которых удалены пробелы.</p>
</div>
<div class="section" id="id73">
<h3>XML<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h3>
<p>Больше нет класса <code class="docutils literal notranslate"><span class="pre">BeautifulStoneSoup</span></code> для разбора XML. Чтобы
разобрать XML, нужно передать “xml” в качестве второго аргумента
в конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code>. По той же причине
конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> больше не распознает
аргумент  <code class="docutils literal notranslate"><span class="pre">isHTML</span></code>.</p>
<p>Улучшена обработка пустых тегов
XML. Ранее при разборе XML нужно было явно указать,
какие теги считать пустыми элементами. Аргумент <code class="docutils literal notranslate"><span class="pre">SelfClosingTags</span></code>
больше не распознается. Вместо этого
Beautiful Soup считает пустым элементом любой тег без содержимого. Если
вы добавляете в тег дочерний элемент, тег больше не считается
пустым элементом.</p>
</div>
<div class="section" id="id74">
<h3>Мнемоники<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h3>
<p>Входящие мнемоники HTML или XML всегда преобразуются в
соответствующие символы Unicode. В Beautiful Soup 3 было несколько
перекрывающих друг друга способов взаимодействия с мнемониками. Эти способы
удалены. Конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> больше не распознает
аргументы <code class="docutils literal notranslate"><span class="pre">smartQuotesTo</span></code> и <code class="docutils literal notranslate"><span class="pre">convertEntities</span></code>. (В <a class="reference internal" href="#unicode-dammit">Unicode,
Dammit</a> все еще присутствует <code class="docutils literal notranslate"><span class="pre">smart_quotes_to</span></code>, но по умолчанию парные кавычки
преобразуются в Unicode). Константы <code class="docutils literal notranslate"><span class="pre">HTML_ENTITIES</span></code>,
<code class="docutils literal notranslate"><span class="pre">XML_ENTITIES</span></code> и <code class="docutils literal notranslate"><span class="pre">XHTML_ENTITIES</span></code> были удалены, так как они
служили для настройки функции, которой больше нет (преобразование отдельных мнемоник в
символы Unicode).</p>
<p>Если вы хотите на выходе преобразовать символы Unicode обратно в мнемоники HTML,
а не превращать Unicode в символы UTF-8, вам нужно
использовать <a class="reference internal" href="#output-formatters"><span class="std std-ref">средства форматирования вывода</span></a>.</p>
</div>
<div class="section" id="id75">
<h3>Прочее<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#string"><span class="std std-ref">Tag.string</span></a> теперь работает рекурсивно. Если тег А
содержит только тег B и ничего больше, тогда значение A.string будет таким же, как
B.string. (Раньше это был None.)</p>
<p><a class="reference internal" href="#id16">Многозначные атрибуты</a>, такие как <code class="docutils literal notranslate"><span class="pre">class</span></code>, теперь в качестве значений имеют списки строк,
а не строки. Это может повлиять на поиск
по классу CSS.</p>
<p>Если вы передадите в один из методов <code class="docutils literal notranslate"><span class="pre">find*</span></code> одновременно <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a> <cite>и</cite>
специфичный для тега аргумент, такой как <a class="reference internal" href="#name"><span class="std std-ref">name</span></a>, Beautiful Soup будет
искать теги, которые, во-первых,  соответствуют специфичным для тега критериям, и, во-вторых, имеют
<a class="reference internal" href="#string"><span class="std std-ref">Tag.string</span></a>, соответствующий заданному вами значению <a class="reference internal" href="#id35"><span class="std std-ref">string</span></a>. Beautiful Soup <cite>не</cite> найдет сами строки. Ранее
Beautiful Soup игнорировал аргументы, специфичные для тегов, и искал
строки.</p>
<p>Конструктор <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> больше не распознает
аргумент <cite>markupMassage</cite>. Теперь это задача парсера —
обрабатывать разметку правильно.</p>
<p>Редко используемые альтернативные классы парсеров, такие как
<code class="docutils literal notranslate"><span class="pre">ICantBelieveItsBeautifulSoup</span></code> и <code class="docutils literal notranslate"><span class="pre">BeautifulSOAP</span></code>,
удалены. Теперь парсер решает, что делать с неоднозначной
разметкой.</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">prettify()</span></code> теперь возвращает строку Unicode, а не байтовую строку.</p>
</div>
</div>
</div>
<div class="section" id="id76">
<h1>Перевод документации<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h1>
<p>Переводы документации Beautiful Soup очень
приветствуются. Перевод должен быть лицензирован по лицензии MIT,
так же, как сам Beautiful Soup и англоязычная документация к нему.</p>
<p>Есть два способа передать ваш перевод:</p>
<ol class="arabic simple">
<li>Создайте ветку репозитория Beautiful Soup, добавьте свой
перевод и предложите слияние с основной веткой — так же,
как вы предложили бы изменения исходного кода.</li>
<li>Отправьте <a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup">в дискуссионную группу Beautiful Soup</a>
сообщение со ссылкой на
ваш перевод, или приложите перевод к сообщению.</li>
</ol>
<p>Используйте существующие переводы документации на китайский или португальский в качестве образца. В
частности, переводите исходный файл <code class="docutils literal notranslate"><span class="pre">doc/source/index.rst</span></code> вместо
того, чтобы переводить HTML-версию документации. Это позволяет
публиковать документацию в разных форматах, не
только в HTML.</p>
<div class="section" id="id78">
<h2>Об этом переводе<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h2>
<p>Перевод на русский язык: <a class="reference external" href="mailto:geekwriter&#37;&#52;&#48;yandex&#46;ru">authoress</a></p>
<p>Дата перевода: февраль 2020</p>
<p>Перевод выполнен с <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">оригинала на английском языке</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Документация Beautiful Soup</a><ul>
<li><a class="reference internal" href="#id5">Техническая поддержка</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">Быстрый старт</a></li>
<li><a class="reference internal" href="#id8">Установка Beautiful Soup</a><ul>
<li><a class="reference internal" href="#id9">Проблемы после установки</a></li>
<li><a class="reference internal" href="#parser-installation">Установка парсера</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">Приготовление супа</a></li>
<li><a class="reference internal" href="#id12">Виды объектов</a><ul>
<li><a class="reference internal" href="#tag"><code class="docutils literal notranslate"><span class="pre">Tag</span></code></a><ul>
<li><a class="reference internal" href="#id14">Имя</a></li>
<li><a class="reference internal" href="#id15">Атрибуты</a><ul>
<li><a class="reference internal" href="#multivalue">Многозначные атрибуты</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#navigablestring"><code class="docutils literal notranslate"><span class="pre">NavigableString</span></code></a></li>
<li><a class="reference internal" href="#beautifulsoup"><code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code></a></li>
<li><a class="reference internal" href="#id17">Комментарии и другие специфичные строки</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">Навигация по дереву</a><ul>
<li><a class="reference internal" href="#id19">Проход сверху вниз</a><ul>
<li><a class="reference internal" href="#id20">Навигация с использованием имен тегов</a></li>
<li><a class="reference internal" href="#contents-children"><code class="docutils literal notranslate"><span class="pre">.contents</span></code> и <code class="docutils literal notranslate"><span class="pre">.children</span></code></a></li>
<li><a class="reference internal" href="#descendants"><code class="docutils literal notranslate"><span class="pre">.descendants</span></code></a></li>
<li><a class="reference internal" href="#string"><code class="docutils literal notranslate"><span class="pre">.string</span></code></a></li>
<li><a class="reference internal" href="#strings-stripped-strings"><code class="docutils literal notranslate"><span class="pre">.strings</span></code> и <code class="docutils literal notranslate"><span class="pre">.stripped_strings</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">Проход снизу вверх</a><ul>
<li><a class="reference internal" href="#parent"><code class="docutils literal notranslate"><span class="pre">.parent</span></code></a></li>
<li><a class="reference internal" href="#parents"><code class="docutils literal notranslate"><span class="pre">.parents</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">Перемещение вбок</a><ul>
<li><a class="reference internal" href="#next-sibling-previous-sibling"><code class="docutils literal notranslate"><span class="pre">.next_sibling</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_sibling</span></code></a></li>
<li><a class="reference internal" href="#next-siblings-previous-siblings"><code class="docutils literal notranslate"><span class="pre">.next_siblings</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_siblings</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id26">Проход вперед и назад</a><ul>
<li><a class="reference internal" href="#next-element-previous-element"><code class="docutils literal notranslate"><span class="pre">.next_element</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_element</span></code></a></li>
<li><a class="reference internal" href="#next-elements-previous-elements"><code class="docutils literal notranslate"><span class="pre">.next_elements</span></code> и <code class="docutils literal notranslate"><span class="pre">.previous_elements</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id27">Поиск по дереву</a><ul>
<li><a class="reference internal" href="#id28">Виды фильтров</a><ul>
<li><a class="reference internal" href="#a-string">Строка</a></li>
<li><a class="reference internal" href="#a-regular-expression">Регулярное выражение</a></li>
<li><a class="reference internal" href="#a-list">Список</a></li>
<li><a class="reference internal" href="#true"><code class="docutils literal notranslate"><span class="pre">True</span></code></a></li>
<li><a class="reference internal" href="#id32">Функция</a></li>
</ul>
</li>
<li><a class="reference internal" href="#find-all"><code class="docutils literal notranslate"><span class="pre">find_all()</span></code></a><ul>
<li><a class="reference internal" href="#name">Аргумент <code class="docutils literal notranslate"><span class="pre">name</span></code></a></li>
<li><a class="reference internal" href="#kwargs">Именованные аргументы</a></li>
<li><a class="reference internal" href="#css">Поиск по классу CSS</a></li>
<li><a class="reference internal" href="#id35">Аргумент <code class="docutils literal notranslate"><span class="pre">string</span></code></a></li>
<li><a class="reference internal" href="#limit">Аргумент <code class="docutils literal notranslate"><span class="pre">limit</span></code></a></li>
<li><a class="reference internal" href="#recursive">Аргумент <code class="docutils literal notranslate"><span class="pre">recursive</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">Вызов тега похож на вызов <code class="docutils literal notranslate"><span class="pre">find_all()</span></code></a></li>
<li><a class="reference internal" href="#find"><code class="docutils literal notranslate"><span class="pre">find()</span></code></a></li>
<li><a class="reference internal" href="#find-parents-find-parent"><code class="docutils literal notranslate"><span class="pre">find_parents()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_parent()</span></code></a></li>
<li><a class="reference internal" href="#find-next-siblings-find-next-sibling"><code class="docutils literal notranslate"><span class="pre">find_next_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next_sibling()</span></code></a></li>
<li><a class="reference internal" href="#find-previous-siblings-find-previous-sibling"><code class="docutils literal notranslate"><span class="pre">find_previous_siblings()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous_sibling()</span></code></a></li>
<li><a class="reference internal" href="#find-all-next-find-next"><code class="docutils literal notranslate"><span class="pre">find_all_next()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_next()</span></code></a></li>
<li><a class="reference internal" href="#find-all-previous-find-previous"><code class="docutils literal notranslate"><span class="pre">find_all_previous()</span></code> и <code class="docutils literal notranslate"><span class="pre">find_previous()</span></code></a></li>
<li><a class="reference internal" href="#id40">Селекторы CSS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id42">Изменение дерева</a><ul>
<li><a class="reference internal" href="#id43">Изменение имен тегов и атрибутов</a></li>
<li><a class="reference internal" href="#id44">Изменение <code class="docutils literal notranslate"><span class="pre">.string</span></code></a></li>
<li><a class="reference internal" href="#append"><code class="docutils literal notranslate"><span class="pre">append()</span></code></a></li>
<li><a class="reference internal" href="#extend"><code class="docutils literal notranslate"><span class="pre">extend()</span></code></a></li>
<li><a class="reference internal" href="#navigablestring-new-tag"><code class="docutils literal notranslate"><span class="pre">NavigableString()</span></code> и <code class="docutils literal notranslate"><span class="pre">.new_tag()</span></code></a></li>
<li><a class="reference internal" href="#insert"><code class="docutils literal notranslate"><span class="pre">insert()</span></code></a></li>
<li><a class="reference internal" href="#insert-before-insert-after"><code class="docutils literal notranslate"><span class="pre">insert_before()</span></code> и <code class="docutils literal notranslate"><span class="pre">insert_after()</span></code></a></li>
<li><a class="reference internal" href="#clear"><code class="docutils literal notranslate"><span class="pre">clear()</span></code></a></li>
<li><a class="reference internal" href="#extract"><code class="docutils literal notranslate"><span class="pre">extract()</span></code></a></li>
<li><a class="reference internal" href="#decompose"><code class="docutils literal notranslate"><span class="pre">decompose()</span></code></a></li>
<li><a class="reference internal" href="#replace-with"><code class="docutils literal notranslate"><span class="pre">replace_with()</span></code></a></li>
<li><a class="reference internal" href="#wrap"><code class="docutils literal notranslate"><span class="pre">wrap()</span></code></a></li>
<li><a class="reference internal" href="#unwrap"><code class="docutils literal notranslate"><span class="pre">unwrap()</span></code></a></li>
<li><a class="reference internal" href="#smooth"><code class="docutils literal notranslate"><span class="pre">smooth()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46">Вывод</a><ul>
<li><a class="reference internal" href="#prettyprinting">Красивое форматирование</a></li>
<li><a class="reference internal" href="#id48">Без красивого форматирования</a></li>
<li><a class="reference internal" href="#output-formatters">Средства форматирования вывода</a></li>
<li><a class="reference internal" href="#get-text"><code class="docutils literal notranslate"><span class="pre">get_text()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id50">Указание парсера</a><ul>
<li><a class="reference internal" href="#id51">Различия между парсерами</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id52">Кодировки</a><ul>
<li><a class="reference internal" href="#id53">Кодировка вывода</a></li>
<li><a class="reference internal" href="#unicode-dammit">Unicode, Dammit</a><ul>
<li><a class="reference internal" href="#id54">Парные кавычки</a></li>
<li><a class="reference internal" href="#id55">Несогласованные кодировки</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id56">Нумерация строк</a></li>
<li><a class="reference internal" href="#id57">Проверка объектов на равенство</a></li>
<li><a class="reference internal" href="#id58">Копирование объектов Beautiful Soup</a></li>
<li><a class="reference internal" href="#id59">Разбор части документа</a><ul>
<li><a class="reference internal" href="#soupstrainer"><code class="docutils literal notranslate"><span class="pre">SoupStrainer</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id60">Устранение неисправностей</a><ul>
<li><a class="reference internal" href="#diagnose"><code class="docutils literal notranslate"><span class="pre">diagnose()</span></code></a></li>
<li><a class="reference internal" href="#id62">Ошибки при разборе документа</a></li>
<li><a class="reference internal" href="#id63">Проблемы несоответствия версий</a></li>
<li><a class="reference internal" href="#xml">Разбор XML</a></li>
<li><a class="reference internal" href="#id64">Другие проблемы с парсерами</a></li>
<li><a class="reference internal" href="#misc">Прочие ошибки</a></li>
<li><a class="reference internal" href="#id66">Повышение производительности</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id68">Beautiful Soup 3</a><ul>
<li><a class="reference internal" href="#bs4">Перенос кода на BS4</a><ul>
<li><a class="reference internal" href="#id70">Вам нужен парсер</a></li>
<li><a class="reference internal" href="#id71">Имена методов</a></li>
<li><a class="reference internal" href="#id72">Генераторы</a></li>
<li><a class="reference internal" href="#id73">XML</a></li>
<li><a class="reference internal" href="#id74">Мнемоники</a></li>
<li><a class="reference internal" href="#id75">Прочее</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id76">Перевод документации</a><ul>
<li><a class="reference internal" href="#id78">Об этом переводе</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Beautiful Soup на русском языке</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/bs4ru.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Beautiful Soup на русском языке"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Beautiful Soup 4.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2004-2020, Leonard Richardson.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>
